[{"title":"ffmpeg知识点","date":"2017-05-03T16:00:00.000Z","path":"2017/05/04/ffmpeg基础知识和win编译/","text":"libavcodec: 用于各种类型声音/图像编解码 libavutil: 包含一些公共的工具函数 libavformat: 包含多种多媒体容器格式的封装丶解封装工具 libswscale: 用于视频场景的比例缩放丶色彩映射转换 libpostproc: 用于后期效果处理 libavdevice: 用于音视频数据采集和渲染等功能的设备相关 ibswresample: 用于音频重采样和格式转换等功能 libavfilter: 包含多媒体处理常用的滤镜功能 ffmpeg的官方网站是：http://ffmpeg.org/编译好的windows可用版本的下载地址（和官网保持同步）：http://ffmpeg.zeranoe.com/builds/ 该网站中的FFMPEG分为3个版本：Static，Shared，Dev。 前两个版本都可以直接在命令行使用： Static：只有3个应用程序：ffmpeg.exe,ffplay.exe,ffprobe.exe。每个exe的体积都很大，相关的Dll都已经被编译到exe里面去了。Shared : 除了上面那三个exe之外，还有一些Dll，比如avcodec-54.dll之类的。shared里面的exe体积很小，他们运行时到相应的Dll中调用功能。Dev : 用于开发，里面包含了库文件xxx.lib以及头文件xxx.h，这个版本不包含exe文件。 ffmpeg :该项目提供的一个工具，可用于格式转换丶解码或电视卡即时编译等。ffprobe : ffprobe是用于查看文件格式的应用程序。ffplay ：是一个简单的播放器，使用ffmpeg库解析和解码，通过SDL显示ffserver ：一个HTTP多媒体即时广播串流服务器。 常用命令集 获取视频的信息ffmpeg -i video.avi 将图片序列合成视频ffmpeg -f image2 -i image%d.jpg video.mpg上面的命令会把当前目录下的图片（名字如：image1.jpg, image2.jpg等..）合成video.mpg 将视频分解成图片序列ffmpeg -i video.mpg image%d.jpg上面的命令会生成image1.jpg,image2.jpg…支持的图片格式有：PGM,PPM,PAM,PGMYUV,JPEG,GIF,PNG,TIFF,SGI 为视频重新编码以适合在ipod/iphone上播放ffmpeg -i source_video.avi input -acodec aac -ab 128kb -vcodec mpeg4 -b 1200kb -mbd 2 -flags +4mv+trell -aic 2 -cmp 2 -subcmp 2 -s 320x180 -title X final_video.mp4说明： 1234567- 源视频：source_vidro.avi- 音频编码：aac- 音频位率：128kb/s- 视频编码：mpeg4- 视频位率：1200kb/s- 视频尺寸：320 X 180- 生成的视频：final_video.mp4 为视频重新编码以适合在PSP上播放ffmpeg -i source_video.avi -b 300 -s 320x240 -vcodec xvid -ab 32 -ar 24000 -acodec aac final_video.np4说明： 1234567+ 源视频：source_video.avi+ 音频编码：aac+ 音频位率：32kb/s+ 视频编码：xvid+ 视频位率：1200kb/s+ 视频尺寸：320 X 180+ 生成的视频：final_video.mp4 从视频抽出声音。并存为Mp3ffmpeg -i source_video.avi -vn -ar44100 -ac 2 -ab 192 -f mp3 sound.mp3说明： 1234* 源视频：source_video.avi* 音频位率：192kb/s* 输出格式：mp3* 生成的声音：sound.mp3 将wav文件转成Mp3ffmpeg -i son_origine.avi -vn -ar 44100 -ac 2 -ab 192 -f mp3 son_final.mp3 将.avi视频转成.mpgffmpeg -i video_origine.avi video_finale.mpg 将.mpg转成.aviffmpeg -i video_origine.mpg video_finale.avi 将.avi转成gif动画（未压缩）ffmpeg -i video_origine.avi gif_anime.gif 合成视频和音频ffmpeg -i son.wav -i video_origine.avi video_finale.mpg 将.avi转成.flvffmpeg -i video_origine.avi -ab 56 -ar 44100 -b 200 -r 15 -s 320x240 -f flv video_finale.flv 将.avi转成dvffmpeg -i video_origine.avi -s pal -r pal -aspect 4:3 -ar 48000 -ac 2 video_finale.dv或ffmpeg -i video_origine.avi -target pal-dv video_finale.dv 将.avi压缩成divxffmpeg -i video_origine.avi -s 320x240 -vcodec msmpeg4v2 video_finale.avi 将Ogg Theora 压缩成Mpeg dvdffmpeg -i film_sortie_cinelerra.ogm -s 720x576 -vcodec mpeg2video -acodec mp3 film_terminate.mpg 将.avi压缩成SVCD mpeg2NTSC格式：ffmpeg -i video_origine.avi -target ntsc-svcd video_finale.mpgPAL格式：ffmpeg -i video_origine.avi -target pal-svcd video_finale.mpg 将.avi压缩成VCD mpeg2NTSC格式：ffmpeg -i video_origine.avi -target ntsc-vcd video_finale.mpgPAL格式：ffmpeg -i video_origine.avi -traget pal-vcd video_finale.mpg 多通道编码ffmpeg -i fichierentree -pass 2 -passlogfile ffmpeg2pass fichiersortie-2 从flv提取mp3ffmpeg -i source.flv -ab 128k dest.mp3 ##win下编译ffmpeg3.3 下载安装MinGW 下载yasm ffmpeg 编辑ffmpeg文件夹下面的configure文件，找到123456789SLIBNAME_WITH_MAJOR='$(SLIBNAME).$(LIBMAJOR)'LIB_INSTALL_EXTRA_CMD='$$(RANLIB) \"$(LIBDIR)/$(LIBNAME)\"'SLIB_INSTALL_NAME='$(SLIBNAME_WITH_VERSION)'SLIB_INSTALL_LINKS='$(SLIBNAME_WITH_MAJOR) $(SLIBNAME)'将其修改成：SLIBNAME_WITH_MAJOR='$(SLIBPREF)$(FULLNAME)-$(LIBMAJOR)$(SLIBSUF)'LIB_INSTALL_EXTRA_CMD='$$(RANLIB) \"$(LIBDIR)/$(LIBNAME)\"'SLIB_INSTALL_NAME='$(SLIBNAME_WITH_MAJOR)'SLIB_INSTALL_LINKS='$(SLIBNAME)' 新建build_android.sh文件注意：要根据环境配置的前四项，且每行末尾不能有空格。export TMPDIR,NDK,SYSROOT,TOOLCHAIN-cross-prefix 一定有12345678910111213141516171819202122232425262728293031323334#!/bin/bashexport TMPDIR=\"D:\\ffmpeg\\tmp\"NDK=D:\\/sdk\\/ndk-bundleSYSROOT=$NDK/platforms\\/android-24\\/arch-arm/TOOLCHAIN=$NDK/toolchains/arm-linux-androideabi-4.9/prebuilt/windows-x86_64function build_one &#123; ./configure \\ --prefix=$PREFIX \\ --enable-shared \\ --disable-static \\ --disable-doc \\ --disable-ffmpeg \\ --disable-ffplay \\ --disable-ffprobe \\ --disable-ffserver \\ --disable-avdevice \\ --disable-doc \\ --disable-symver \\ --cross-prefix=$TOOLCHAIN/bin/arm-linux-androideabi- \\ --target-os=linux \\ --arch=arm \\ --enable-cross-compile \\ --sysroot=$SYSROOT \\ --extra-cflags=\"-Os -fpic $ADDI_CFLAGS\" \\ --extra-ldflags=\"$ADDI_LDFLAGS\" \\ $ADDITIONAL_CONFIGURE_FLAG make clean make make install &#125; CPU=arm PREFIX=$(pwd)/android/$CPU ADDI_CFLAGS=\"-marm\" build_one 然后在MinGW中cd进ffmpeg目录。命令： chomd 777 ./build_android.sh./build_android.sh 开始编译 编译完成后在FFmpeg下会多一个Android文件夹。","tags":[{"name":"ffmpeg","slug":"ffmpeg","permalink":"https://github.com/LouisShark/tags/ffmpeg/"},{"name":"android","slug":"android","permalink":"https://github.com/LouisShark/tags/android/"}]},{"title":"手动实现arraylist和hashmap","date":"2017-05-02T08:37:26.000Z","path":"2017/05/02/手动实现arraylist和hashmap/","text":"这是第一篇博客，我准备先将最近学习的笔记记录下来，数据结构最基础也最难吧，大佬就别看了。。。 Arraylist public class LouisArraylist&lt;E&gt; { int size; Object[] array; private static final int MIN_CAPACITY_INCREMENT = 12; public LouisArraylist(int capacity){ if(capacity&lt;0){ throw new IllegalArgumentException(); } array = new Object[capacity]; } public LouisArraylist(){ array = new Object[0]; } public LouisArraylist(Collection&lt;? extends E&gt; collection){ Object[] a = collection.toArray(); if(a.getClass()!=Object[].class){ Object[] newArray = new Object[a.length]; System.arraycopy(a, 0, newArray, 0, a.length); a = newArray; } array = a; size = a.length; } /** * 扩容 * */ private static int newCapacity(int currentCapacity){ int increment = (currentCapacity&lt;MIN_CAPACITY_INCREMENT/2)?MIN_CAPACITY_INCREMENT :currentCapacity&gt;&gt;1; return currentCapacity+increment; } /** * 增加 */ public boolean add(E object){ Object[] a = array; int s = size; if(s == a.length){ //需要扩容了 Object[] newArray = new Object[newCapacity(s)]; System.arraycopy(a, 0, newArray, 0, s); array = a = newArray; } a[s] = object; size = s + 1; return true; } public int size(){ return size; } public boolean isEmpty(){ return size==0; } /** * 查找首次出现元素的下标 */ public int indexOf(Object object){ Object[] a = array; int s = size; if(object!=null){ for(int i = 0;i&lt;s;i++){ if(object.equals(a[i])){ return i; } } }else{ for(int i = 0;i&lt;s;i++){ if(a[i] == null){ return i; } } } return -1; } public int lastIndexOf(Object object){ Object[] a = array; int s = size; if(object!=null){ for(int i = s -1;i &gt;= 0;i--){ if(object.equals(a[i])){ return i; } } }else{ for(int i = s -1;i &gt;= 0;i--){ if(a[i] == null){ return i; } } } return -1; } /** * 删除某个元素 */ public E remove(int index){ Object [] a = array; int s = size; if(index &gt;= s){ throw new IndexOutOfBoundsException(); } E e = (E) a[index]; System.arraycopy(a, index+1, a, index, --s-index); a[s] = null; size = s; return e; } /** * 删除某个元素 */ public boolean remove(Object object){ Object[] a = array; int s = size; if (object == null) { for (int i = 0; i &lt; size; i++) { if (a[i] == null) { remove(i); return true; } } } else { for (int i = 0; i &lt; size; i++) { if (a[i].equals(object)) { remove(i); return true; } } } return false; } public E set(int index,E object){ Object[] a = array; if(index&gt;size){ throw new IndexOutOfBoundsException(); } E e = (E) a[index]; a[index] = object; return e; } /** * 获取 */ public E get(int index){ Object[] a = array; if(index&gt;size){ throw new IndexOutOfBoundsException(); } E e = (E) a[index]; return e; } } 代码已经说明的很清楚了，我就不多说什么了，知道底层是数组实现就ok了 HashMap public class LouisHashMap { private int size; private static final int MINIMUN_CAPACITY = 1 &lt;&lt; 2; private static final int MAXNIMUN_CAPACITY = 1 &lt;&lt; 30; //阈值 private int threshhold; //用于强制扩容,因为比minimun还小 private static final Map.Entry[] EMPTY_TABLE = new LouisEntry[MINIMUN_CAPACITY &gt;&gt; 1]; private LouisEntry&lt;K, V&gt;[] table; //核心数组 LouisEntry&lt;K, V&gt; entryOrNullKey; //空键entry public LouisHashMap() { table = (LouisEntry&lt;K, V&gt;[]) EMPTY_TABLE; threshhold = -1; } public LouisHashMap(int capacity) { if (capacity &lt; 0) { throw new IllegalArgumentException(&quot;capacity :&quot; + capacity); } else if (capacity == 0) { table = (LouisEntry&lt;K, V&gt;[]) EMPTY_TABLE; threshhold = -1; return; } else if (capacity &lt; MINIMUN_CAPACITY &amp;&amp; capacity &gt; 0){ capacity = MINIMUN_CAPACITY; } else if (capacity &gt; MAXNIMUN_CAPACITY) { capacity = MAXNIMUN_CAPACITY; } else { capacity = roundUpToPowerOfTwo(capacity); } makeTable(capacity); } /** * 添加 * @param key * @param value * @return */ public V put(K key, V value) { if (key == null) { return putValueForNullKey(value); } int hash = sencondaryHash(key.hashCode()); LouisEntry&lt;K, V&gt;[] tab = table; //将一个很散列的值 位与一个索引大小，会取得0~索引的值 int index = hash &amp; (table.length - 1); //先检查是否存在相同的键 for (LouisEntry&lt;K, V&gt; e = tab[index]; e != null; e = e.next) { //键相同hash值一定相同， hash相同键不一定相同 if (e.hash == hash &amp;&amp; key.equals(e.getKey())) { V oldValue = e.getValue(); e.setValue(value); return oldValue; } } //没有覆盖直接插入元素 if (size++ &gt; threshhold) { //创建一个新的容量的数组 tab = doubleCapacity(); index = hash &amp; (tab.length - 1); } addNewEntry(key, value, hash, index); return null; } private void addNewEntry(K key, V value, int hash, int index) { //将新创建的entry加在链表头，一句代码解决两个事情，放头部，放容易查询也容易 table[index] = new LouisEntry&lt;&gt;(key, value, hash, table[index]); } /** * get * @return */ public V get(Object key) { if (key == null) { LouisEntry&lt;K, V&gt; e = entryOrNullKey; return e == null ? null : e.getValue(); } int hash = sencondaryHash(key.hashCode()); LouisEntry&lt;K, V&gt;[] tab = table; int index = hash &amp; (tab.length - 1); for (LouisEntry&lt;K, V&gt; entry = tab[index]; entry != null; entry = entry.next) { K ekey = entry.key; //比较时，先比较对象值是否相等，在比较属性值是否相等，增加效率 if (ekey == key || (entry.hash == hash &amp;&amp; key.equals(ekey))) { return entry.value; } } return null; } /** * 双倍扩容 * @return */ private LouisEntry&lt;K, V&gt;[] doubleCapacity() { LouisEntry&lt;K, V&gt;[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXNIMUN_CAPACITY) { return oldTable; } //2的幂次方 int newCapacity = oldCapacity &lt;&lt; 1; System.out.println(&quot;扩容：&quot; + size); LouisEntry&lt;K, V&gt;[] newTable = makeTable(newCapacity); if (size == 0) { return newTable; } //开始重新散列 for (int j = 0; j &lt; oldTable.length; j++) { LouisEntry&lt;K, V&gt; e = oldTable[j]; //拿到每个键值对 if (e == null) { continue; //因为每个索引不一定有值，hash } // 与上面 int index = hash &amp; (table.length - 1);会出现两组数据，一种还在远处，一种去到length的位置 int highBit = e.hash &amp; oldCapacity; LouisEntry&lt;K, V&gt; broken = null; //位或 运算最多是原值的两倍，重新一次散列 newTable[j | highBit] = e; for (LouisEntry&lt;K, V&gt; n = e.next; n != null; e = n, n = n.next) { //n 为当前遍历的元素， e为前一个 int nextHighBit = n.hash &amp; oldCapacity; if (nextHighBit != highBit) { if (broken == null) { int nextNewIndex = j | nextHighBit; //新的索引的位置 newTable[nextNewIndex] = n; } else { broken.next = n; } broken = e; highBit = nextHighBit; } } if (broken != null) { broken.next = null; } } return newTable; } /** * hashMap键的hash算法 * @param h * @return */ private int sencondaryHash(int h) { h ^= (h&gt;&gt;&gt;20)^(h&gt;&gt;&gt;12); return h^(h&gt;&gt;&gt;7)^(h&gt;&gt;&gt;4); } /** * 放空键的键值对 * @param value * @return */ private V putValueForNullKey(V value) { LouisEntry&lt;K, V&gt; entry = entryOrNullKey; if (entry == null) { addNewEntryForNullKey(value); size++; return null; } else{ V oldValue = entry.getValue(); entry.setValue(value); return oldValue; } } private void addNewEntryForNullKey(V value) { entryOrNullKey = new LouisEntry&lt;K, V&gt;(null, value, 0, null); } /** * 根据容量创建核心数组 * @param capacity */ private LouisEntry&lt;K, V&gt;[] makeTable(int capacity) { LouisEntry&lt;K, V&gt;[] newTable = new LouisEntry[capacity]; table = newTable; threshhold = (capacity &gt;&gt;&gt; 2) + (capacity &gt;&gt;&gt; 1); return newTable; } private int roundUpToPowerOfTwo(int i) { i--; i |= i &gt;&gt;&gt; 1; // i = i | (i &gt;&gt;&gt; 1) 让所有的位都变成 1 ， 最后在加 1，就可以被2整除 i |= i &gt;&gt;&gt; 2; i |= i &gt;&gt;&gt; 4; i |= i &gt;&gt;&gt; 8; i |= i &gt;&gt;&gt; 16; return i + 1; } public int getSize() { return size; } /** * 键值对类 * @param &lt;K&gt; * @param &lt;V&gt; */ static class LouisEntry&lt;K, V&gt; implements Map.Entry&lt;K, V&gt; { final int hash; final K key; //此处用final 只赋值一次，因为key是唯一的 V value; LouisEntry&lt;K, V&gt; next; public LouisEntry(K key, V value, int hash, LouisEntry&lt;K, V&gt; next) { this.key = key; this.value = value; this.hash = hash; this.next = next; } @Override public K getKey() { return key; } @Override public V getValue() { return value; } @Override public V setValue(V value) { V oldValue = this.value; this.value = value; return oldValue; } @Override public int hashCode() { // ^ 异或运算使结果更加散列，相同为0 return (key == null ? 0 :key.hashCode()) ^ (value == null ? 0 : value.hashCode()); } } } 第一次写博客，注释也很多了，兄弟们自己将就看吧。","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://github.com/LouisShark/tags/数据结构/"},{"name":"java","slug":"java","permalink":"https://github.com/LouisShark/tags/java/"}]},{"title":"Hello World","date":"2017-04-19T09:58:12.666Z","path":"2017/04/19/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]