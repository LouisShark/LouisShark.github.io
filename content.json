[{"title":"kotlin academy's trouble","date":"2018-06-09T03:15:48.000Z","path":"2018/06/09/kotlin-academy-s-trouble/","text":"Kotlin puzzlers 话说已经好久没写blog了呢，又是失踪人口回归，我一直觉得不能强迫自己为了写博客而写博客，总是要为了记录点什么才行，这次我就刚好见到kotlin academy发的邮件，瞥了一眼觉得很多易错的题目蛮好(鬼畜)的，就忍不住想写了blog记录一下啦。 原文地址： Kotlin Academy 以下题目的答案和解析都下一题揭晓啦（学自夜雀 逃。 Order of nullable operators （猫王操作符的优先级 重要提示Level：Beginner 1234567fun main(args: Array&lt;String&gt;) &#123; val x: Int? = 2 val y: Int = 3 val sum = x?:0 + y println(sum)&#125; What will it print ? Some possibilities: //这个不用翻译了吧… a. 3 b. 5 c. 2 d. 0 Author: Thomas Nield Contravariance (逆变)Level：Beginner 12345class Wrapper&lt;in T&gt;val instanceVariableOne: Wrapper&lt;Nothing&gt; = Wrapper&lt;Any&gt;() //Line Aval instanceVariableTwo: Wrapper&lt;Any&gt; = Wrapper&lt;Nothing&gt;() //Line B What does it display? Some possibilities: a. Both lines A and B compile. b. Lines A and B do not compile. c. Line A compiles;Line B does not. d. Line B compiles;Line A does not. Author：Allan Caine 上题答案： c. 2 解析： Elvis operator(猫王操作符，我脑补)，比+具有更低优先级的操作符，所以 +会先被计算， 即 sum = x ?: ( 0 + y) = x ?: 3 = 2, 使用小括号可以正确计算。 Interface delegation and data classesLevel：Expert 123456789data class Container( val name: String, private val items: List&lt;Int&gt;) : List&lt;Int&gt; by itemsfun main(args: Array&lt;String&gt;) &#123; val (name, items) = Container(\"Kotlin\", listOf(1, 2, 3)) println(\"Hello $name, $items\")&#125; What will it print? Some possibilities: a. Hello Kotlin,[1, 2, 3] b. Hello Kotlin, 1 c. Hello 1, 2 d. Hello Kotlin, 2 Author: Nikolas Havrikov 上题答案： c. Line A compiles;Line B does not. 解析： Wrapper&lt;in T&gt; 中的T是逆变的。 Wrapper的类型应该与T的子类型相反，即 super T。 因为Nothing是Any的子类型(注:Nothing 是其他所有类型的子类型)，所以Wrapper&lt;Any&gt; 是Wrapper&lt;Nothing&gt;的子类型。 Line A compiles。他将一个子类型赋值给超类。 Line B does not compile。 他将一个超类赋值给子类。 WTF with labelsLevel：Advanced 123456fun main(args: Array&lt;String&gt;) &#123; val j = wtf@&#123; n: Int -&gt; wtf@(wtf@n + wtf@2) &#125;(10) print(j)&#125; What does it display? Some possibilities: a. It won’t compile b. 10 c. 2 d. 12 Author: Dmitry Kandaloy 上题答案： d. Hello Kotlin, 2 解析： private val items使Container.component2() 私有化。 public List&lt;T&gt;.component2()定义在kotlin-stdlib中的扩展函数。 Container用by delegation的方式实现了接口List&lt;Int&gt;，因此调用了上面的扩展函数。 所以，(name, items)解构后第二个参数就是伪代码就是listOf(1, 2, 3).component2() 你可以在JB的issue tracker中找到以下讨论： https://youtrack.jetbrains.com/issue/KT-24308 Return in Function literalLevel：Beginner 12345678910111213141516fun f1() &#123; (1..4).forEach&#123; if (it == 2) return println(it) &#125;&#125;fun f2() &#123; (1..4).forEach(fun(it) &#123; if (it == 2) return println(it) &#125;)&#125;fun main(args: Array&lt;String&gt;) &#123; f1() f2()&#125; What does it display? Some possibilities: a. 134134 b. 1134 c. 1341 d. Doesn’t compile. Author: Marcin Moskala 上题答案： d. 12 解析： 哈哈哈，这就是一个很普通的lambda表达式加上一堆的label啦。别想多 Int plus-plusLevel：Beginner 123456789fun main(args: Array&lt;String&gt;) &#123; var i = 0 println(i.inc()) println(i.inc()) var j = 0 println(j++) println(++j) &#125; What does it display? Some possibilities: a. 0, 1, 0, 1 b. 0, 1, 0, 2 c. 1, 1, 0, 2 d. 1, 2, 0, 2 Author: Dmitry Kandalov 上题答案： b. 1134 解析： 当我们想要在lambda表达式中使用return即从闭包返回的时候，我们需要使用label标签，譬如return@forEach. 因为for-each是内联函数同时允许非局部返回，所以return就会结束f1方法。 Function namesLevel：Expert 1234fun ``() &#123;&#125;fun ` `() &#123;&#125;fun `everything works.`() &#123;&#125;fun `1/1/ is ok; 1/0 is an error`()&#123;&#125; Which functions have acceptable names? Some possibilities: a. ok; ok; ok; ok b. error; ok; ok; error; c. error; ok; error; error; d. error; error; error; error; Author: Dmitry Kandalov 上题答案： c. 1, 1, 0, 2 解析： 前缀++（++j）增加数值并且返回增加后新的值，但是后缀++（i++）虽然同样增加数值但它返回的是未增加老的值。 本题带有迷惑的地方是kotlin函数inc()的前缀和后缀.详细请看 递增和递减 Receivers warsLevel：Advanced 1234567891011121314151617181920212223242526fun foo() &#123; println(\"Top-level rule\")&#125;class Foo &#123; fun foo() &#123; println(\"Extension receiver rule\") &#125;&#125;class Test &#123; fun foo() &#123; println(\"Dispatch receiver rule\") &#125; fun Foo.foo() &#123; println(\"Member extension function rule\") &#125; fun Foo.test() &#123; foo() &#125; fun testFoo() &#123; Foo().test() &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; Test().testFoo()&#125; Which does it display? Some possibilities: a. Top-level rule b. Extension receiver rule c. Dispatch receiver rule d. Member extension function rule Author: Marcin Moskalatma 上题答案： c. error; ok; error; error; 解析： :声明必须要有名字 :Ok 和 4. : 命名包含非法字符，”,” “;” 和 “/“ Negative numbersLevel：Advanced 12345fun main(args: Array&lt;String&gt;) &#123; println(-1.inc()) println(\", \") println(1 + -(1))&#125; Which does it display? Some possibilities: a. 0, 0 b. Won’t compile in line 4 c. 0, 2 d. -2, 0 Author: Marcin Moskala 上题答案： b. Extension receiver rule 解析： 当我们有一个扩展接收者(Foo)时，接收者的方法(method)要优先于同class内的其他函数。 不可能会打印“Member extension function rule”,因为当方法(method)和扩展函数(extension function)有冲突时，方法(method)总是胜利。 Child applyLevel：Advanced 12345678910111213141516open class Node(val name: String) &#123; fun lookup() = \"lookup in: $name\"&#125;class Example: Node(\"container\") &#123; fun createChild(name: String): Node? = Node(name) val child1 = createChild(\"child1\")?.apply &#123; println(\"child1 $&#123;lookup()&#125;\") &#125; val child2 = createChild(\"child2\").apply &#123; println(\"child2 $&#123;lookup()&#125;\") &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; Example()&#125; Which does it display? Some possibilities: a. child1 lookup in: child1;child2 lookup in : child2 b. child1 lookup in: child1;child2 lookup in : container c. child1 lookup in: container;child2 lookup in : child2 d. none of the above Author: Dmitry Kandalov 上题答案： d. -2, 0 解析： 这两种情况我们都给Int使用了前缀减(unaryMinus())操作符，-1和1.unaryMinux()是相等的。这就是为什么1+ -(1)是正常的。 -1.inc()返回 -2是因为inc是先使用的操作符，这表达式和1.inc().unaryMinus()是相等的. 可以加括号来解决此问题，(-1).inc()。 Subtypes and Generics: ListLevel：Advanced 123456sealed class LinkedList&lt;T&gt;data class Node&lt;T&gt;( val payload: T, var next: LinkedList&lt;T&gt; = EmptyList) : LinkedList&lt;T&gt;()object EmptyList : LinkedList&lt;Nothing&gt;() Will it compile?If not, what do I need to do? Some possibilities: a. Looks great.This code will compile as is. b. A sealed class cannot have a type parameter. c. Write sealed class LinkedList. d. Write sealed class LinkedList Author: Allan Caine 上题答案： b. child1 lookup in: child1;child2 lookup in : container 解析： createChild 返回一个可空的对象，所以child2的apply的接收者是Node？。 我们不能在未解包的情况下直接调用lookup.如果想要调用则应该使用this?.lookup()。 因为没有这样做，编辑器会找他能使用的lookup方法，即Example的上下文的lookup。 CopyLevel：Advanced 12345678data class Container(val list: MutableList&lt;String&gt;)fun main(args: Array&lt;String&gt;) &#123; val list = mutableListOf(\"one\", \"two\") val c1 = Container(list) val c2 = c1.copy() list += \"oops\" println(c2.list.joinToString())&#125; What does it display? Some possibilities: a. one, two. b. one,two,oops c. UnsupportedOperationException d. will not compile Author: Anton Keks 上题答案： d. Write sealed class LinkedList 解析： 目前所写的代码不能正确编译。Node&lt;T&gt;的属性next不能给EmptyList的默认值。 LinkedList&lt;T&gt;对于泛型T是不变的。而EmptyList是LinkedList&lt;Nothing&gt;。无论T的类型是什么LinkedList&lt;Nothing&gt;都是唯一类型。 而只要使LinkedList关于T协变，即使LinkedList&lt;Nothing&gt;是每个LinkedList的子类型，因为Nothing是任意类型的子类型。 密封类可以有类型参数(type parameters). Kotlin object不能有类型参数(type parameters). 所以b错 如果LinkedList是逆变的，LinkedList&lt;Nothing&gt;就变成所有LinkedList的父类型。然而本题要求的是子类型 更多解释可以参考： https://blog.kotlin-academy.com/kotlins-nothing-its-usefulness-in-generics-5076a6a457f7 Cyclic object constructionLevel：Expert 12345678open class A(val x: Any?)object B : A(C)object C : A(B)fun main(args: Array&lt;String&gt;) &#123; println(B.x) println(C.x)&#125; What does it print? Some possibilities: a. null; null b.C@2de80c; null c. ExceptionInInitializerError d. will not compile Author: Hiroshi Kurokawa 上题答案： b. one,two,oops 解析： data class的copy方法是一个浅拷贝(仅复制字段的引用)。使得data class immutable 来避免此类问题。 Overriding properties that are used in a parentLevel：Expert 1234567open class Parent(open val a: String) &#123; init &#123; print(a) &#125; &#125;class Children(override val a: String): Parent(a)fun main(args: Array&lt;String&gt;) &#123; Children(\"abc\")&#125; What will it print? Some possibilities: a. abc b.Unresolved reference: a c.Nothing,it won’t compile d. null 上题答案： b.C@2de80c; null 解析： Singleton对象的初始化顺序是通过尝试按照他们的依赖关系进行拓扑排序来确定的。 在初始化周期的情况下，完整的拓扑排序是不可能的，并且有可能观察循环中涉及的对象的值为null， 如果将此值传递给期望不可为空类型的函数，则可能导致异常 如果A的构造函数取非空的参数，就会抛出异常 B 初始化需要 C，C 初始化需要 B。咦，B 还没初始化完成呢，那么哪来的 B 呢，只能是 null 了啊！ 取自夜雀博客 参考链接：http://jetbrains.github.io/kotlin-spec/#_singleton_objects 本题答案： d. null 解析： 这是kotlin的implement已知的最大问题，请看一下java代码 12345678910111213141516171819202122&gt; public static class Parent&#123;&gt; private final String a;&gt; public String getA()&#123;&gt; return this.a;&gt; &#125;&gt; Parent(String a) &#123;&gt; super();&gt; this.a = a;&gt; System.out.print(this.getA());&gt; &#125;&gt; &#125;&gt; public static final class B extends Parent &#123;&gt; private final String a;&gt; public String getA() &#123;&gt; return this.a;&gt; &#125;&gt; B(String a) &#123;&gt; super(a);&gt; this.a = a;&gt; &#125;&gt; &#125;&gt; &gt; 正如你所看到的，使用getA方法来获得a，唯一的问题是a被重写在Child 它实际上是引用Child里的a，那时候还没被赋值，因为parent总是被先初始化。 在kotlin/js 也有相同的问题，结果是undefined。 题目太多了，也就不全部摘写完了，想看的同学去这里看，好了写完了溜了。","tags":[{"name":"-kotlin -易错题","slug":"kotlin-易错题","permalink":"//louisshark.github.io/tags/kotlin-易错题/"}]},{"title":"Kotlin的柯里化","date":"2018-02-10T16:13:40.000Z","path":"2018/02/11/Kotlin的柯里化/","text":"难得今天休息了一天，就一直在睡觉，突然看到群里有人说到Kotlin的柯里化，正好最近在学习Kotlin，就想要记录一下。想到自己很久没动的博客(懒..不是忙)，垂死病中惊坐起，意识到自己不能继续颓废下去了，赶紧爬起来写了这篇博客，也算是新年有个好开始吧。以后尽量把博客捡起来。。。 Koltin是什么语言我也不想多说了，google的推荐让这个东西着实火了一把，我也就怀着好奇心去学了下，因为以前一直写Java(写的时间也不久)，确实被Kotlin的扩展函数，重载操作符，空安全给吸引到了，说实话，写了Kotlin，我真的觉得Java在这个时代有点过去式的感觉。。不多说了，看标题就知道我今天要说的是什么了。 ###柯里化 这是一个神奇的东西，Java未曾出现过，起码在java8之前(即使是8我觉得也不是标准的Curry，只是像而已)，虽然Kotlin没有这个语法糖，但对于可以FP的Kotlin来说，这都不是事。 维基百科这样说道：在计算机科学中，柯里化（英语：Currying），又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术. 可能有些人觉得很困惑，确实，对没接触过fp的语言的人来说确实有点难懂。没事，Talk is cheap, show you code. ####举个栗子：有时候我们想要打印一些东西，于是我们如是写道12345678910in:fun log(tag: String, target: OutputStream, message: Any?) &#123; target.write(\"$tag $message\\n\".toByteArray())&#125;fun main(args: Array&lt;String&gt;) &#123; log(\"louis\", System.out, \"what f**k\")&#125;output:louis what f**k 一个简单的实现就完成了，但是我们看着不爽啊，这方法调着有点烦人啊(只是个例子，不要较真)，于是我们想到了柯里化。 初次修改后：123456789101112131415in:fun logCurry(tag: String): (target: OutputStream) -&gt; (message: Any?)-&gt; Unit&#123; return fun (target: OutputStream): (message: Any?) -&gt; Unit &#123; return fun (message: Any?) &#123; return target.write(\"$tag $message\\n\".toByteArray()) &#125; &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; logCurry(\"louis\")(System.out)(\"what f**k\")&#125;output:louis what f**k 简单的柯里化函数就完成了，但是这代码，喔吼，不是变得很麻烦了吗，看起来也不简单啊，没事我再改一下。 123456789101112in:fun log(tag: String) = fun (target: OutputStream) = fun (message: Any?) = target.write(\"$tag $message\\n\".toByteArray())fun main(args: Array&lt;String&gt;) &#123; log(\"louis\")(System.out)(\"what f**k\")&#125;output:louis what f**k 这就是把他柯里化的最终版本了，其实也只是利用了fp的范式，看到这里你应该要骂人了，这哪里简单了，没关系，我们写Kotlin，要的就是简单易读(骚)，我们不还有扩展函数吗，给这种东西写个柯里化的扩展还不是分分钟吗，仔细看。 1234567891011121314in:fun &lt;P1, P2, P3, R&gt; Function3&lt;P1, P2, P3, R&gt;.curried(): (P1) -&gt; (P2) -&gt; (P3) -&gt; R &#123; return fun (p1: P1): (P2) -&gt; (P3) -&gt; R &#123; return fun (p2: P2): (P3) -&gt; R &#123; return fun (p3: P3): R &#123; return this(p1, p2, p3) &#125; &#125; &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; ::log.curried()(\"louis\")(System.out)(\"what f**k\")&#125; ::log是method reference(函数引用)，java8后也有这个概念，这就不多说了，另一个故事了，你应该看到了，我们给三个参数的函数写了个扩展方法，这样我们所有三个参数的函数柯里化就可以直接调这个扩展函数了。 其实柯里化本身很简单，难的是他的概念。 这东西我也是记录一下，现在差不多写完了，收工睡觉了。 谢谢你看到这里看到发牢骚&gt;_&lt;。。。","tags":[{"name":"kotlin","slug":"kotlin","permalink":"//louisshark.github.io/tags/kotlin/"},{"name":"笔记","slug":"笔记","permalink":"//louisshark.github.io/tags/笔记/"}]},{"title":"Binder随意记录","date":"2017-12-12T09:42:15.000Z","path":"2017/12/12/Binder/","text":"[TOC] ###为何选择Binder Linux已经拥有管道，system V IPC，socket等IPC手段，却还要依赖Binder来实现进程间通信，说明Binder具有无可比拟的优势。 ####传输性能好Binder的优点之一就是，复杂数据类型传递可以复用内存。 socket：是一个通用接口，导致其传输效率低，开销大，主要用在跨网络的进程间通信和本机上进程间的低速通信。 管道和消息队列：因为采用存储转发方式，所以至少需要拷贝2次数据，效率低。 共享内存：虽然在传输时没有拷贝数据，但其控制机制复杂。 IPC 数据拷贝次数 共享内存 0 Binder 1 Socket/管道/消息队列 2 ####安全性高传统IPC没有任何安全措施，完全以来上层协议来确保。首先传统IPC的接收方无法获得对方进程可靠的UID/PID（用户ID/进程ID），从而无法鉴别对方身份。 Android为每个安装好的应用程序分配了自己的UID，故进程的UID是鉴别进程身份的重要标志。可靠的身份标识只有IPC机制本身在内核中添加。 传统IPC访问接入点是开放的，无法建立私有通道，Binder可以使用匿名Binder建立私密通道，别的进程就无法通过穷举或猜测等任何方式获得该Binder的引用，向该Binder发送请求。 易用性 Binder使用的是C/S通信方式，一个进程可以开启服务专门负责处理某个模块的业务，多个进程可以作为Client同时向Server发起请求。 使用了面向对象的设计，发起一次binder call 就像在调用本地方法一样简单。 一次拷贝？ 当Client向Server发送数据时，Client会先从自己的进程空间把通信数据拷贝到内核空间，因为Server和内核共享数据，所以不在需要重新拷贝数据，而是直接通过内存地址的偏移量直接获取到数据地址。总体来说拷贝了一次。 Server和内核空间之所以能够共享一块空间数据主要是通过binder_mmap来实现的。它的主要功能是在内核的虚拟地址空间申请一块和用户虚拟内存相同大小的内存，然后在申请一个page大小的内存，将它映射到内核虚拟地址空间和用户虚拟内存空间，从而实现了用户空间缓存和内核空间缓冲同步的功能。 Binder总体架构 在Android系统中，运行在内核空间的，负责各个用户进程通过Binder通信的内核模块叫做Binder驱动，Binder驱动虽然默默无闻，确是通信的核心，尽管叫“驱动”，实际上和硬件设备没有任何关系，只是实现方式和设备驱动程序是一样的。 面向对象思想的引入将进程间通信转化为通过对某个Binder对象的引用调用该对象的方法，而其独特之处在与Binder对象是一个可以跨进程引用的对象，他的实体位于一个进程中，而他的引用确遍布系统的各个进程中。最诱人的是这个引用和java里引用一样既可以是强类型，也可以是弱类型，而且从一个进程传给其他进程，让大家都能访问同一个server，就像讲一个对象或引用赋值给另一个引用一样。Binder模糊了进程边界，淡化了进程间通信过程。整个系统仿佛运行于同一个面向对象的程序之中。形形色色的Binder对象以及星罗棋布的引用仿佛粘连各个应用程序的胶水。 首先Binder分为Binder对象和Binder驱动，即Binder驱动就是主要的内核模块，而这个Binder对象是通讯的载体，可以自由的通过Bidner驱动自由穿梭任意进程。所以客户端或者服务器就可以把数据放入Binder对象里，然后进行调用和通讯。类似胞吞胞吐。 Binder框架定义了四个角色：Server，Client，ServiceManager以及Binder驱动。 Server进程里的Binder对象指的是Binder本地对象，Client里面的对象指的是Binder代理对象；在Binder对象进行跨进程传递的时候，Binder驱动会自动完成这两种类型的转换；因此Binder驱动必然保存每一个跨进程的Binder对象的相关信息；在驱动中，Binder本地对象的代表是一个是一个叫做binder_node的数据结构，Binder代理对象 是用binder_ref代表的；有得地方把Binder本地对象直接称作Binder实体，把Binder代理对象直接称作 Binder引用（句柄）。 ServiceManager与实名Binder ServiceManager是一个进程，Server是另一个进程，Server向SM中注册Binder必然会涉及到进程间通信。当前实现的是进程间通信却又要用到进程间通信，就好像蛋孵出鸡的前提却是鸡孵蛋。Binder的实现比较巧妙，预先创造一只鸡来孵蛋：SM和其他进程间同样采用Binder通信，SM是Server端，有自己的Binder对象（实体），其他进程都是Client，需要通过这个Binder的引用来实现Binder的注册，查询和获取。SM提供的Binder比较特殊，他没有名字也不需要注册，当一个进程使用BINDER_SET_CONTEXT_MGR命令将自己注册在SM时Binder驱动会自动为他创建Binder实体（这就是预先造好的鸡）。其次这个Binder的引用在所有Client中都固定为0而无须通过其他手段获得。也就是说，一个Server若要向SM注册自己Binder就必需通过0这个引用号和SM的Binder通信。类比网络通信，0号引用就好比域名服务器的地址，你必须预先手工或动态配置好。 首先，Server在自己的进程中向Binder驱动申请创建一个Server的Binder实体。 Binder驱动为这个Server创建位于内核中的Binder实体节点以及Binder的引用。（在Binder驱动中创建一块内存） 然后Server通过0这个引用号和SM的的Binder通信 将名字和新建的引用打包传递给SM（实体没有传给SM），通知SM注册一个名叫XXX的Server。 SM收到数据包后，从中取出Server名字和引用，填入一张查找表中。 Server初始化的时候，SM做了以下操作： 为binder分配128k的内存 通知binder驱动，使自身成为binder驱动的“DNS” 维护一个监听Server的死循环，并且维护持有所有Server句柄的svclist 添加Server的时候，进行权限，内存（充足）进行判断，如果没有添加过则将Server添加至svclist。 Client获得实名Binder的引用 Server向SM注册了Binder引用及其名字后，Client就可以通过名字获取该Binder的引用了。Client也利用保留的0号引用向SM请求访问某个Binder：我申请获得名字叫张三的Binder的引用。SM收到这个连接请求，从请求数据包里获得Binder的名字，在查找表里找到该名字对应的条目，从条目中取出Binder的引用，将该引用作为回复发送给发起请求的Client。从面向对象的角度，这个Binder对象 现在有两个引用：一个位于SM中，一个位于发送请求的Client中。如果接下来有更多的Client请求该binder，系统中就会有更多的引用指向该Binder，就像Java里一个对象存在多个引用一样。而且类似的这些指向Binder的引用是强类型，从而确保只要有引用Binder实体就不会被释放掉。 Client与Server通讯 client向SM发送申请服务Server的请求，那么SM就可以在查找表中找到该Service的Binder引用。并把Binder引用（BpBinder）返回给Client，此时Client便可以通过这个引用向Server（间接）发起调用，Binder引用将参数包装然后交给驱动并获取Server的调用结果。 Binder的线程管理 每个binder的Server进程会创建很多线程来处理Binder请求，可以简单的理解为创建了一个Binder的线程池（虽然实际上并不完全是这样简单的线程管理方式），而真正管理这些线程并不是由这个Server端来管理的，而是由Binder驱动进行管理的。 一个进程的Binder线程数默认最大是16，超过的请求会被阻塞等待空闲的Binder线程。你做进程间通信时处理并发问题就会有一个底，比如使用ContentProvider时，你就很清楚他的CRUD方法只能同时有16个线程在跑。（应用与ContentProvider为不同进程时）。 四大组件中常见的2个binder服务是？一个是实现了IActivityManager接口的ActivityManagerNative，ActivityManagerService是他的子类，提供了AMS中的所有服务，从APP调用binder call到AMS都是同步的，APP需要阻塞等待AMS执行完毕。 一个是实现了IApplicationThread接口的ApplicationThreadNative，ActivityThread中的内部类ApplicationThread是他的子类，AMS可以发起异步请求到APP，不需要等待APP执行完成。 BpBinder：Binder的代理对象，内部有一个成员变量mHandle，记录着远侧滑盖服务对象的handle BBinder：Binder本地服务对象 binder_ref与binder_node有什么区别 binder_ref与binder_node都存在于内核空间 binder_node是实体对象、binder_ref是引用对象 binder_node被binder_ref引用，binder_ref被BpBinder引用 应用如何获取和添加Binder服务获取与添加Binder服务的操作是交给大管家ServiceManager实现的；ServiceManager进程启动后会通过binder_loop睡眠等待客户端的请求，如果进程被客户端唤醒就会调用svcmgr_handler来处理获取或者添加服务的请求 ServiceManager也是一种Binder服务，当应用获取ServiceManager服务的代理时，它的handle句柄固定为0，所以才不需要去查找，123456789101112private static IServiceManager getIServiceManager() &#123; if (sServiceManager != null) &#123; return sServiceManager; &#125; // Find the service manager sServiceManager = ServiceManagerNative.asInterface(BinderInternal.getContextObject()); return sServiceManager;&#125;sp&lt;IBinder&gt; ProcessState::getContextObject(const sp&lt;IBinder&gt;&amp; /*caller*/)&#123; return getStrongProxyForHandle(0); &#125; Binder协议中BC与BR开头的协议都有什么区别？ BC_：全称Binder Command，进程发送给Binder驱动数据时携带的协议 BR_：全程Binder Return，Binder驱动发送给进程数据时携带的协议 Binder服务在调用期间抛出了RuntimeException异常，服务端会Crash吗服务端不会Crash，RuntimeException被Binder服务端线程捕捉，随后将异常信息写入到reply中，发回Binder客户端进程，最后客户端binder线程会抛出这个异常，如果没有捕捉到这个RuntimeException，那么Binder客户端进程会Crash。 客户端调用Binder接口后抛出的DeadObjectException是什么意思？之所以抛出DeadObjectException最常见的原因是Binder服务端进程已经死亡。客户端进行binder调用时，Binder驱动发现服务端进程不能回应请求，那么就会抛出异常给客户端。 还有一些比较生僻的原因，比如服务端此时的缓存内存空间（1016k）已经被占满了，Binder驱动就认为服务端此时并不能处理这个调用，那么就会在C++层抛出DeadObjectException到Java层。 Binder驱动加载过程中有哪些重要的步骤？ binder_init：初始化Binder驱动环境，内核工作队列、文件系统节点、misc设备等 binder_open：打开Binder设备，获取Binder驱动的文件描述符（fd） binder_mmap：将用户进程地址空间映射到Binder驱动设备内存。这也是Binder能够实现一次拷贝以来的根本。 binder_ioctl：Binder的驱动的核心功能，用来进行数据读写操作 Binder的死亡通知机制的作用是什么，如何实现？Binder服务端进程死亡后，依赖着Binder实体对象的客户端代理对象也会失效。当Binder服务无效时，驱动程序会发送死亡通知给各个已注册服务的客户端进程，以方便客户端做些销毁之类的操作。 思维通知机制最常用在APP和AMS服务，是典型的C/S架构，当APP端的进程死亡后，其ApplicationThreadNative会被销毁，随后Binder驱动会发出死亡通知给AMS，方便清理已经失效的四大组件及应用进程信息。 binder驱动的加载阶段会打开/dev/driver文件，当服务端的进程死亡后，系统会进入清理阶段，关闭所有与进程相关联的资源，这其中就包含了关闭/dev/driver文件描述符的操作，随后就会调用到Binder驱动的binder_release方法，结果层层调用最后会调用到binderDied这个回调方法。如果APP进程之前注册并实现过DeathRecipient这个接口，此时APP就能对Server进程的死亡做出处理。 bindService所绑定的“服务概念和Binder中的服务Server有什么区别”bindService绑定的服务所指的是四大组件中的Service；调用context.bindService方法可以让Activity与Service形成一种“绑定”的概念。这个概念是在Android Framework定义，形成“绑定”的关系之后，Activity除了能够和Service进行通信之外，他们所在的进程存活状态也会相关联。注意，这个Service不确定是运行在本地还是远端，大部分情况下我们调用startService只是用来启动一个在本地定义的Service组件。当使用bindService时，一般是需要调用Service通过onBind返回的Binder服务接口，以此实现Activity与Service之间的通信。 Binder服务则是一个真正的C/S架构中的服务端角色。这个服务需要继承Binder类并实现一套服务接口才能生效。我们常见的ActivityManagerService正是一个继承了Binder类并运行在system_server的服务，用来提供四大组件以及进程方面的服务。 注意，调用bindService后，Service.onBind方法会返回Binder服务Stub对象，然后APP会在AMS进行登记，然后经过层层调用才会在Binder客户端调用onConnected方法，如果Binder客户端和其服务端在同一个进程，客户端拿到的应该还是Stub对象，如果不在同一进程中，客户端拿到的应该是Binder服务的Proxy对象。 本质上，bindService锁绑定的服务和Binder的服务属于同一类，他们实现进程间通信的原理都是借助了Binder这一套机制。 writeStrongBinder与readStrongBinder的作用和原理主要作用是实现两个进程之间的双工通信。还是以APP客户端的ApplicationThread和system_server服务端的ActivityManagerService这两个Binder服务来举例子，这两个服务的接口的大致模式都相同。 每个进程最多存在多少个Binder线程，这些线程都被占满后会导致什么问题？123456789101112// --frameworks/nativebs/binder/ProcessState.cpp#define DEFAULT_MAX_BINDER_THREADS 15static int open_driver()&#123; int fd = open(\"/dev/binder\", O_RDWR); if (fd &gt;= 0) &#123;... size_t maxThreads = DEFAULT_MAX_BINDER_THREADS; result = ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads); &#125; return fd;&#125; Binder线程池中的线程数量是在Binder驱动初始化时被定义的，进程池中的线程个数上限为15个，加上主Binder线程，一共最大能存在16个binder线程； 当binder线程都在执行工作时，也就是当出现线程饥饿的时候，从别的进程调用的binder请求如果是同步的话，会在todo队列中阻塞等待，直到线程池中有空闲的binder进程来处理请求。 binder传输数据的最大限制是多少，占满后会导致什么问题123456789101112131415161718// --frameworks/nativebs/binder/ProcessState.cpp#define BINDER_VM_SIZE ((1*1024*1024) - (4096 *2))ProcessState::ProcessState() : mDriverFD(open_driver()) , mVMStart(MAP_FAILED) , mThreadCountLock(PTHREAD_MUTEX_INITIALIZER) , mThreadCountDecrement(PTHREAD_COND_INITIALIZER) , mExecutingThreadsCount(0) , mMaxThreads(DEFAULT_MAX_BINDER_THREADS) , mManagesContexts(false) , mBinderContextCheckFunc(NULL) , mBinderContextUserData(NULL) , mThreadPoolStarted(false) , mThreadPoolSeq(1)&#123; // mmap the binder, providing a chunk of virtual address space to receive transactions. mVMStart = mmap(0, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, 0);&#125; 在调用mmap时会指定Binder内存缓冲区的大小为1016k；当服务端的内存缓冲区被Binder进程占用满后，Binder驱动不会在处理binder调用并在c++层抛出DeadObjectException到binder客户端。同步空间是1016k，异步空间只有他的一半，也就是508k。123456789101112131415161718192021// --kernel/msm-3.18/drivers/staging/android/binder_alloc.cstruct binder_buffer *binder_alloc_new_buf(struct binder_alloc *alloc, size_t data_size, size_t offsets_size, size_t extra_buffers_size, int is_async)&#123;...if (is_async &amp;&amp; // 当Binder缓存空间不足时将会出现异常，Binder驱动不再会派发这个binder请求 alloc-&gt;free_async_space &lt; size + sizeof(struct binder_buffer)) &#123; binder_alloc_debug(BINDER_DEBUG_BUFFER_ALLOC, \"%d: binder_alloc_buf size %zd failed, no async space left\\n\", alloc-&gt;pid, size); eret = ERR_PTR(-ENOSPC); goto error_unlock;&#125;error_unlock:mutex_unlock(&amp;alloc-&gt;mutex);return eret;&#125; Binder驱动什么时候释放缓冲区的内存是在binder call之后，调用Parcel.recycle来完成释放内存的。12345678910public int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options) throws RemoteException &#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0); reply.recycle(); data.recycle(); return result;&#125; 为什么使用广播传输2MB的Bitmap会跑异常，而使用AIDL生成的Binder接口传输Bitmap就不会抛异常呢？通过Binder直接传输Bitmap，如果bitmap的大小大于128k，那么传输Bitmap内容的方式就会使用ashmem，Binder只需要负责传输ashmem的fd到服务端即可。这种Binder+ashmem的方式在Android中很常见，比如四大组件的ContentProvider.query方法，从Provider中查找的数据通常会超过1016k这个限制，使用ashmem不仅能突破这个限制，还有提高大量数据传输的效率 使用广播来传输跨进程传输数据的话则不一样，bitmap是被填入到Bundle中，随后以Parcelable的序列化方式传输到AMS的，如果Bundle数据量大于800k，就会抛出TrasnactionTooLargeException的异常 依据Bitmap是否过大来使用ashmem还是Binder的方式传输内容的逻辑在native层的Bitmap_createFromParcel。 应用程序为什么支持Binder通信，直接可以使用四大组件呢?所有应用的进程都是通过调用AMS.startProcessLocked方法来fork Zygote进程创建的；Zygote在启动时会在preloadClasses中预先加载上千个类，而在fork子进程时，这些操作就不需要在做了，大大节约了子进程的启动时间。 应用进程的Binder驱动初始化的操作正是在zygote fork自身之后做的。system_server与zygote的通信使用socket，之所以不使用binder的原因很简单，socket的使用对于写这个功能的工程师来说更简单。 在zygote进程的初始化操作完成后，zygote会通过socket返回给system_server pid，随后AMS会将pid和应用的Application进行绑定。也就是说在应用调用Application.onCreate之前，binder驱动的初始化就已经完成了，所以直接就可以使用Binder来通信。","tags":[{"name":"Binder","slug":"Binder","permalink":"//louisshark.github.io/tags/Binder/"},{"name":"android","slug":"android","permalink":"//louisshark.github.io/tags/android/"}]},{"title":"几分钟手写一个双向链表","date":"2017-11-07T06:42:15.000Z","path":"2017/11/07/几分钟手写一个双向链表/","text":"链表和顺序表 首先，对比一下顺序表和链表 顺序表 优点：尾插效率高，支持随机访问 缺点：中间插入或者删除效率低 应用：ArrayList .. 单链表 优点： 头插，中间插，删除效率高 缺点：不支持随机访问 应用场景：MessageQueue 为什么循序表的中间插入和删除的效率低呢？为什么链表的头插尾插删除效率高呢？ 还是看源码，就从ArrayList和LinkedList看看： ArrayList： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public void add(int index, E element) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125;public static void arraycopy(Object src, int srcOfs, Object dest, int destOfs, int len) &#123; if (src == null || dest == null) &#123; throw new NullPointerException(); &#125; Class&lt;?&gt; srcType = src.getClass(); Class&lt;?&gt; destType = dest.getClass(); if (!srcType.isArray() || !destType.isArray()) &#123; throw new ArrayStoreException(\"Must be array types\"); &#125; Class&lt;?&gt; srcComp = srcType.getComponentType(); Class&lt;?&gt; destComp = destType.getComponentType(); if (srcComp.modifiers != destComp.modifiers || (srcComp.isPrimitive() &amp;&amp; !srcComp.equals(destComp))) &#123; throw new ArrayStoreException(\"Array types must match\"); &#125; int srclen = getArrayLength(src); int destlen = getArrayLength(dest); if (srcOfs &lt; 0 || destOfs &lt; 0 || len &lt; 0 || srcOfs + len &gt; srclen || destOfs + len &gt; destlen) &#123; throw new IndexOutOfBoundsException(); &#125; /* * If the arrays are not references or if they are exactly the same type, we * can copy them in native code for speed. Otherwise, we have to copy them * in Java so we get appropriate errors. */ if ((!srcComp.isPrimitive() || srcComp.isArray()) &amp;&amp; !srcType.equals(destType)) &#123; // copy in Java to make sure we get ArrayStoreExceptions if the values // aren't compatible Object[] srcArray = (Object[]) src; Object[] destArray = (Object[]) dest; if (src == dest &amp;&amp; srcOfs &lt; destOfs) &#123; // TODO(jat): how does backward copies handle failures in the middle? // copy backwards to avoid destructive copies srcOfs += len; for (int destEnd = destOfs + len; destEnd-- &gt; destOfs;) &#123; destArray[destEnd] = srcArray[--srcOfs]; &#125; &#125; else &#123; for (int destEnd = destOfs + len; destOfs &lt; destEnd;) &#123; destArray[destOfs++] = srcArray[srcOfs++]; &#125; &#125; &#125; else &#123; nativeArraycopy(src, srcOfs, dest, destOfs, len); &#125; &#125; 从以上可以看出主要通过数组内存的拷贝来进行添加，越在中间越耗时。 LinkedList： 12345678910111213141516171819202122232425262728293031323334353637public void add(int index, E element) &#123; checkPositionIndex(index); if (index == size) linkLast(element); else linkBefore(element, node(index));&#125; /** * Links e as last element. */void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++;&#125; /** * Inserts element e before non-null Node succ. */void linkBefore(E e, Node&lt;E&gt; succ) &#123; // assert succ != null; final Node&lt;E&gt; pred = succ.prev; final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); succ.prev = newNode; if (pred == null) first = newNode; else pred.next = newNode; size++; modCount++;&#125; 而链表因为他的存储是不连续的，改一下引用或者叫指针就ok了，所以速度很快。 但是链表查找是是非常慢的，特别是在中间的时候。 123456789101112131415161718/** * Returns the (non-null) Node at the specified element index. */Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; 只能通过迭代来查找目标。 为了性能考虑，请在选择时谨慎，尤其是在大数据的情况下。 说了这么多手写一下LinkedList吧。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166/** * @author LouisShark * @mail mshark.louis@gmail.com */public class LouisLinkedList&lt;E&gt; &#123; private Node&lt;E&gt; first; private Node&lt;E&gt; last; private int size; public LouisLinkedList() &#123; &#125; public void add(E e) &#123; linkLast(e); &#125; public void add(int index, E e) &#123; checkIndexValid(index); if (index == size) &#123; linkLast(e); &#125; else &#123; linkBefore(e, node(index)); &#125; &#125; /** * 在p之前插入 */ void linkBefore(E e, Node&lt;E&gt; p) &#123; final Node&lt;E&gt; pred = p.prev; final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, p); p.prev = newNode; if (pred == null) first = newNode; else pred.next = newNode; size++; &#125; /** * 查找的方法 * @param index */ public E get(int index) &#123; checkIndexValid(index); return node(index).item; &#125; /** * 删除节点的方法 * 头尾节点的删除特殊对待 * @param index * @return */ public E remove(int index) &#123; checkIndexValid(index); Node&lt;E&gt; target = node(index); return unlink(target); &#125; private E unlink(Node&lt;E&gt; p) &#123; final E old = p.item; /** * 记录删除节点的前驱和后继 防止后来的更改带来的破坏 */ final Node&lt;E&gt; pre = p.prev; final Node&lt;E&gt; next = p.next; if (pre == null) &#123; //说明是头结点 直接将当前结点的后继赋值给头结点 first = next; &#125; else &#123; //将节点的后继赋值给上个节点的后继 断开节点的前驱(设置为null) pre.next = next; p.prev = null; &#125; if (next == null) &#123; //声明是尾节点 直接将当前结点的前驱赋值给尾节点 last = pre; &#125; else &#123; //将节点的前驱赋值给下个节点的前驱 断开节点的后继(设置为null) next.prev = pre; p.next = null; &#125; p.item = null; size--; return old; &#125; private void checkIndexValid(int index) &#123; if (index &gt;= size || index &lt; 0) &#123; throw new ArrayIndexOutOfBoundsException(\"index越界\"); &#125; &#125; /** * Returns the (non-null) Node at the specified element index. * 查找索引处节点的方法 * 这里判断index在前一半还是后一半进行查找的优化(因为链表只能遍历查找，不像顺序表一样可以随机访问) */ private Node&lt;E&gt; node(int index) &#123; if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) &#123; x = x.next; &#125; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) &#123; x = x.prev; &#125; return x; &#125; &#125; /** * 尾部插入的方法 * 尾部插入就是吧pre指向last，next指向null * 这里要注意是否插入的是第一个节点 * @param e */ private void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) &#123; first = newNode; &#125; else &#123; l.next = newNode; &#125; size++; &#125; private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125; &#125; public int getSize() &#123; return size; &#125; public void setSize(int size) &#123; this.size = size; &#125;&#125; 实现一个简单的增删改查功能还是很快的吧，代码里注释也写的很清楚了。","tags":[{"name":"数据结构","slug":"数据结构","permalink":"//louisshark.github.io/tags/数据结构/"}]},{"title":"搭建nginx","date":"2017-10-11T07:13:33.000Z","path":"2017/10/11/搭建ngnix/","text":"最近萌生搭建一个流媒体服务器的想法，因为自己在写一些音视频的东西，所以就想搞一个玩一玩。本篇在ubuntu16.04下成功。 第一部分：准备工作先在/root/下新建一个目录存放这些文件。 mkdir nginxcd nginx 然后在执行下面三条命令。 下载Nginxwget http://nginx.org/download/nginx-1.12.1.tar.gz 下载OpenSSL(因为Nginx依赖于OpenSSL)wget https://github.com/openssl/openssl/archive/OpenSSL_1_1_0f.tar.gz 下载Rtmpwget https://github.com/arut/nginx-rtmp-module/archive/v1.2.0.tar.gz 第二部分 编译 cd openssl-OpenSSL_1_1_0f/ mkdir bin ./config –prefix=`pwd`/bin 上面这条执行完之后会出现Makefile文件，接下来正式编译 make install 然后回到Nginx目录下 cd nginx-1.12.1/ cd auto/lib/openssl/ 然后修改conf文件 vim conf 123456789101112131415161718192021222324252627282930 if [ $ngx_found = no ]; then # MacPorts ngx_feature=\"OpenSSL library in /opt/local/\" ngx_feature_path=\"/opt/local/include\" if [ $NGX_RPATH = YES ]; then ngx_feature_libs=\"-R/opt/local/lib -L/opt/local/lib -lssl -lcrypto $NGX_LIBDL\" else ngx_feature_libs=\"-L/opt/local/lib -lssl -lcrypto $NGX_LIBDL\" fi . auto/feature fiif [ $ngx_found = no ]; then # 自己添加的一个判断 ngx_feature=\"OpenSSL library in /root/nginx/openssl-OpenSSL_1_1_0f/bin/\" ngx_feature_path=\"/root/nginx/openssl-OpenSSL_1_1_0f/bin/include\" if [ $NGX_RPATH = YES ]; then ngx_feature_libs=\"-R/root/nginx/openssl-OpenSSL_1_1_0f/bin/lib -L/root/nginx/openssl-OpenSSL_1_1_0f/bin/lib -lssl -lcrypto $NGX_LIBDL\" else ngx_feature_libs=\"-L/root/nginx/openssl-OpenSSL_1_1_0f/bin/lib -lssl -lcrypto $NGX_LIBDL\" fi . auto/feature fi 回到nginx目录下，开始编译nginx。 cd /root/nginx/nginx-1.12.1/ ./configure –prefix=`pwd`/bin –add-module=/root/nginx/nginx-rtmp-module-1.2.0 make install 之后会多一个bin目录就代表成功了，来到这个目录下的sbin执行 ./nginx 如果碰到错误 error while loading shared libraries:libssl.so.1.1: cannot open shared object file: No such file or directory 可以 vim /etc/ld.so.conf 在其中加入 /root/nginx/openssl-OpenSSL_1_1_0f/bin/lib 然后执行 Ldconfig保存设置，在去配置一下服务器的入端口 1935 8080. 然后关闭nginx服务器，将nginx-rtmp-module/test/下的nginx.conf 复制到 nginx/bin/conf下面 修改一下 将路径都改为自己的rtmp-module的路径在重启就OK了。","tags":[{"name":"流媒体服务器 ubuntu","slug":"流媒体服务器-ubuntu","permalink":"//louisshark.github.io/tags/流媒体服务器-ubuntu/"}]},{"title":"C++编程风格笔记","date":"2017-09-11T06:19:25.000Z","path":"2017/09/11/C++编程风格笔记/","text":"C++编程风格笔记 定义函数时，参数顺序为：输入参数在前，输出参数在后。 C/C++函数参数分为输入参数和输出参数两种，有时输入参数也会输出（值被修改时），输入参数一般传值或常数引用，输出参数或输入/输出常数为非常数指针(non-const pointers)。对参数排序时，将所有输入参数置于输出参数之前。不要仅仅因为是新添加的参数，就将其置于最后，而应该依然置于输出参数之前。 包含文件的名称及次序 将包含次序标准化可增强可读性丶避免隐藏依赖(hidden dependencies， 隐藏依赖主要指包含的文件中编译时)，次序如下：C库丶C++库丶其他库的.h丶项目内的.h。 项目内头文件应按照项目源代码目录树结构排序，并且避免使用UNIX文件路径。//.(当前路径) ..（父路径）。//例如，google-awesome-project/src/base/logging.h应像这样被包含： 1#include \"base/logging.h\" dir/foo.cc的主要作用是执行或测试dir2/foo2.h的功能，foo.cc中包含头文件的次序如下： 12345dir2/foo2.hC系统文件C++系统文件其他库头文件本项目内头文件 这种排序方式可有效减少隐藏依赖，我们希望每一个头文件都独立编译。最简单的实现方式是将其作为第一个.h文件包含在对应的.cc中。 dir/foo.cc和 dir2/foo2.h通常位于相同目录下（像base/basictypes_unittest.cc和base/basictypes.h），但也可在不同的目录下。 相同目录下头文件按字母排序是不错的选择。 举例来说，“google-awesome-project/src/foo/internal/fooserver.cc”的包含次序如下： 12345678#include &quot;foo/public/fooserver.h&quot; //优先位置#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;hash_map&gt;#include &lt;vector&gt;#include &quot;base/basictypes.h&quot;#include &quot;base/commandlineflags.h&quot;#include &quot;foo/public/bar.h&quot; 总结以上： 避免多重包含是学编程时最基本的要求。 前置声明是为了降低编译依赖，防止修改一个头文件引发多米诺效应。 内联函数的合理使用可提高代码执行效率。 -inl.h 可提高代码可读性。 标准化函数参数顺序可以提高可读性和以易维护性(对函数参数的堆栈空间有轻微影响) 包含文件的名称使用.和..虽然方便却易混乱，使用比较完整的项目路径看上去很清晰丶很条理，包含文件的次序除了美观之外，最重要的是可以减少隐藏依赖，使每个头文件在“最需要编译”的地方编译(对应源文件处)，有人提出库文件放在最后，这样出错先是项目内的文件，头文件都放在对应源文件的最前面，这一点足以保证内部错误的即时发现了。 局部变量 将函数尽可能置于最小作用域内，在声明变量时将其初始化。 C++允许在函数的任何位置声明变量。提倡在尽可能小的作用域内声明变量，离第一次使用越近越好。这使得代码易于阅读，易于定位变量的声明位置丶变量类型和初始值。特别是，应使用初始化代替声明+赋值的方式。 123int i;i = f(); //坏 ---- 初始化和声明分离int j = g()； //好------初始化时声明 注意：gcc可正确执行for(int i =0; i &lt; 10 ;++i)(i的作用域仅限for循环),因此其他for循环可重用i。if和 while 等语句中，作用域声明同样是正确的。 1while(const char* p= strchr(str, &apos;/&apos;)) str = p +1; 注意：如果变量是一个对象，每次进入作用域都要调用其构造函数，每次退出都要调用其析构函数。 //低效的实现 1234for(int i = 0; i &lt; 1000000; ++i) &#123; Foo f; f.DoSomething();&#125; 类似变量要放到循环作用域外面声明要高效的多： 1234Foo f;for (int i = 0; i &lt; 1000000; ++i) &#123; f.DoSomething();&#125; 全局变量 class类型的全局变量是被禁止的，内建类型的全局变量是允许的，当然多线程代码中非常数全局变量也是被禁止的。永远不要使用函数返回值初始化全局变量。如果一定要使用class类型的全局变量，请使用单例模式(singleton pattern)。 对于全局的字符串常量，使用C风格的字符串，而不要使用STL的字符串： 1const char kFrogSays[] = &quot;ribbet&quot;; 虽然允许在全局作用域使用全局变量，但请三思。大多数全局变量应该是类的静态数据成员，或者当其只在.cc文件中使用时，将其定义到不具名命名空间中，或者使用静态关联以限制变量的作用域。 记住，静态成员变量视作全局变量，所以也不能是class类型！！ 总结： .cc文件中的不具名空间可避免命名冲突丶限定作用域，避免直接使用using提示符污染命名空间。 嵌套类符合局部使用原则，只是不能在其他头文件中前置声明，尽量不要public。 尽量不用全局函数和全局变量，考虑作用域和命名空间限制，尽量单独形成编译单元。 多线程中的全局变量(含静态成员变量)不要使用class类型(含STL容器)，避免不明确行为导致的bugs。 作用域的使用，除了考虑名称污染可读性之外，主要是为降低耦合度，提高编译丶执行效率。 类 介绍类该做声明，不该做什么。 explicit: 明确的 implicit: 隐含的 trivial: 没有意义的 non-trivial: 有意义的 #1.构造函数的职责 构造函数中只进行那些没有实际意义的初始化(trivial，简单初始化对于程序执行没有实际的逻辑意义，因为成员变量的“有意义”的值大多不在构造函数中确定)，可能的话，使用Init()方法集中初始化为有意义的数据(non-trivial). 定义：在构造函数中执行初始化操作。 优点：排版方便，无需担心类是否初始化。 缺点：在构造函数中执行操作引起的问题有： 构造函数不易报告错误，不能使用异常 操作失败会造成对象初始化失败，引起不确定状态 构造函数内调用虚函数，调用不会派发到子类实现中，即时当前没有子类化实现，将来仍是隐患 如果有人创建该类型的全局变量，构造函数将在main()之前被调用，有可能破坏构造函数中暗含的假设条件 结论：如果对象需要有意义的(non-trivial)初始化，考虑使用另外的Init()方法并增加一个成员标志用于指示对象是否初始化成功。 ###2.默认构造函数 如果一个类定义了若干成员变量又没有其他构造函数，需要定义一个默认构造函数，否则编译器将自动生产默认构造函数。 定义：新建一个没有参数的对象时，默认构造函数被调用，当调用new[]（为数组）时，默认构造函数总是被调用。 优点：默认将结构体初始化为“不可能的值。”，使调试更加容易。 缺点：对代码编写者来说是多余的工作。 结论： 如果类中定义了成员变量，没有提供其他构造函数，你需要定义一个默认构造函数(无参数)。默认构造函数更适合初始化对象，使对象内部状态(internal state)一致，有效。 提供默认构造函数的原因是：如果倪没有提供其他构造函数，又没有定义默认构造函数。编译器会自动生成一个，但编译器生成的构造函数不会对对象进行初始化。 如果你定义的类继承现有类，而你又没有增加新的成员变量，则不需要为新类定义默认构造函数。 ###3.明确的构造函数(Explicit Constructors) 对单参数构造函数使用C++关键字explicit。 定义：只有一个参数的构造函数可被用于转换(只要指隐式转换)。例如，定义了Foo::Foo(string name),当向需要传入一个Foo对象的函数传入一个字符串时，构造函数Foo::Foo(string name)被调用并将该字符串转换为一个Foo临时对象传给调用函数。看上去方便，但是如果你并不希望通过转换生成一个新对象的话，麻烦也随着而来，为避免构造函数被调用造成隐式转换，可以将其声明为explicit。 优点：避免不合时宜的转换 缺点：无 结论 所有单参数构造函数必须是明确的(explicit)。在类定义中，将关键字explicit加到单参数构造函数前： explicit Foo(string name) 例外：在少数情况下，拷贝构造函数可以不声明为explicit；特意作为其他类的透明包装器的类。 4.拷贝构造函数仅在代码中需要拷贝一个类对象的时候使用拷贝构造函数；不需要拷贝时应使用DISALLOW_COPY_AND_ASSIGN。 定义：通过拷贝新建对象时可使用拷贝构造函数(特别是对象的传值时). 优点：拷贝构造函数使得拷贝对象更加容易，STL容器要求所有内容可拷贝丶可赋值。 缺点：C++中对象的隐式拷贝是导致很多性能问题和bugs的根源。拷贝构造函数降低了代码可读性，相比于按引用传递，跟踪按值传递的对象更加困难，对象修改的地方变得难以琢磨。 结论： 大量的类并不需要可拷贝，也不需要一个拷贝构造函数或赋值操作。但不幸的是，你不主动声明他们，编译器会为你自动生成，而且是public。 可以考虑在类的private中添加空的(dummy)拷贝构造函数和赋值操作，只有声明，没有定义。由于这些空程序声明为private，当其他代码视图使用他们时，编译器将报错，为了方便，可以使用宏定义DISALLOW_COPY_AND_ASSIGN。 123456789101112//禁止使用拷贝构造函数和赋值操作的宏//应在类的private:中使用#define DISALLOW_COPY_AND_ASSIGN(TypeName) \\ TypeName(const TypeName&amp;); \\ void operator = (const TypeName&amp;)class Foo &#123; public: Foo(int f); ~Foo(); private: DISALLOW_COPY_AND_ASSIGN(Foo);&#125;; 如上所述，绝大多数情况应使用DISALLOW_COPY_AND_ASSIGN,如果类确实需要拷贝，应在该类的头文件中说明原由，并适当定义拷贝构造函数和赋值操作，注意在operator中检测自赋值(self-assignment)情况。 在将类作为STL容器值的时候，你可能有使类可拷贝的冲动。类似情况下，真正该做的是使用指针指向STL容器中的对象，可以考虑使用 std::tr1::shared_ptr. 5.结构体和类（struct vs Classes）仅当只有数据时使用struct，其他一律使用class。 在C++中，关键字struct和class几乎含义等同，我们为其认为添加语义，以便为定义的数据类型合理选择使用哪个关键字。 struct被用在仅包含数据的消极对象(passive objetcts)上，可能包括有关联的常量，但没有存取数据成员之外的函数功能，而存取功能通过直接访问实现而无需方法调用，这提到的方法是只用于处理数据成员的，如构造函数丶析构函数丶Initialize()丶Reset()丶Validate(). 如果需要更多的函数功能，class更适合，如果不确定，直接使用class。 如果与STL结合，对于仿函数(functors)和特性(traits)可以不用class而是使用struct。 6.继承(inheritance)使用组合(composition)通常比继承更适宜，如果使用继承的话，只是用公共继承。 定义：当子类继承基类时，子类包含了父基类所有数据及操作的定义。C++中，继承主要用于两个场合：1.实现继承，子类继承父类的实现代码。2.接口继承，子类仅继承父类的方法名称。 优点：实现继承通过原封不动的重用基类代码减少了代码量。由于继承是编译时声明，编码者和编译器都可以理解相应操作并发现错误。接口继承可用于程序上增强类的特定API的功能，在类没有定义API的必要实现时，编译器同样可以甄错。 缺点：对于实现继承，由于实现子类的代码在父类和子类间延展，要理解其实现变得更加困难。子类不能重写父类的非虚函数，当然也就不能修改其实现。基类也可能定义一些数据成员，还要区分基类的物理轮廓(physical layout)。 结论： 所有继承必须是public的，如果想私有继承的话，应该采取包含基类实例作为成员的方式作为替代。 不要过多实现继承，组合通常更合适一些。努力做到只在“是一个”的情况下使用继承；如果Bar的确是一种Foo，才令Bar是Foo的子类。 必要的话，析构函数必须是virtual，必要是指，如果该类具有虚函数，其析构函数应该为虚函数。 至于子类没有额外数据成员，父类也没有任何数据成员的特殊情况下，析构函数的调用是否必要是语义争论，从编程设计规范的角度看，在含有虚函数的父类中，定义虚函数绝对必要。 限定仅在子类访问的成员函数为protected，需要注意数据成员应该始终为私有。 当重定义派生的虚函数时，在派生类中明确声明其为virtual。根本原因：如果遗漏virtual，阅读者需要检索其所有祖先以确定该函数是否为虚函数。 7.多重继承真正需要多重实现继承的时候非常少，只有当最多一个基类中含有实现，其他基类都是以Interface为后缀的纯接口类时才会使用多继承。 定义：多重继承允许子类拥有多个基类，要将作为纯接口的基类和具有实现的基类区别开来。 优点：相比于单继承，多重实现继承可令你重用更多代码 缺点：真正需要用到多重实现继承的时候非常少，多重实现继承看上去是不错的解决方案，通常可以找到更加明确丶清晰丶不同的解决方案 结论： 只有当所有超类除第一个外都是纯接口时才能使用多重继承。为确保它们是纯接口，这些类必须以Interface为后缀。 8.接口接口是指满足指定特定条件的类，这些类以interface为后缀(非必须)。 当一个类满足以下条件时，称为纯接口： 只有纯虚函数(“=0”)和静态函数(下文提到的析构函数除外)。 没有非静态数据成员。 没有定义任何构造函数。如果有也不含参数，并且为protected。 如果是子类，也只能继承满足以上条件并以interface为后缀的类。 接口类不能被直接实例化，因为它声明了纯虚函数。为确保接口类的所有实现可被正确销毁，必须为之声明虚析构函数(作为第一条的例外，析构函数不可能为纯虚函数)。 优点：以interface为后缀可令他人知道不能为该接口类增加实现函数或非静态数据成员，这一点对多重继承尤其重要 缺点：interface后缀增加了类名长度，为阅读和理解带来不变，接口特性作为实现细节不应暴露给客户。 结论： 只有在满足上述需要时，类才以interface结尾，但反过来满足上述需要的类未必一定以interface结尾。 9.操作符重载除少数特定环境外，不要重载操作符。 定义：一个类可以定义诸如 + 丶/等操作符，使其可以像内建类型一样直接使用。 优点：是代码看上去更加直观，就像内建类型(如int)那样，重载操作符使那些equal丶add等暗淡无关的函数名好玩多了。为了使一些模板函数正确工作，可能需要定义操作符。 缺点：虽然操作符重载令代码更加直观，但也有一些不足。 混淆直觉，让你误以为一些耗时操作像内建操作那样轻巧 查找重载操作符的调用处更加困难，查找equal显然比同等调用==容易的多。 有的操作符可以对指针进行操作，容易导致bugs丶Foo+4 做的是一件事，而&amp;Foo+4 可能做的是完全不同的另一件事，对于二者，编译器都不会报错，使其很难调试。 重载还有令你吃惊的副作用，比如重载操作符&amp;的类不能被前置声明。 结论： 一般不要重载操作符，尤其是赋值操作(operator==)比较阴险，应避免重载，需要的话可以定义类似equal丶copyFrom等函数。 然而，极少数情况下需要重载操作符以便与模板或“标准”C++类衔接(operator&lt;&lt;(ostream&amp;,const T&amp;)),如果被证明是正当的尚可接受，但你要尽可能避免这样做尤其是不要仅仅为了在STL容器中作为key使用就重载operator==或operator&lt;，取而代之，你应该在声明容器的时候，创建相等判断和大小比较的仿函数类型。 有些STL算法确实需要重载operator==时可以这么做，不要忘了提供文档说明原因。 参考拷贝构造函数和函数重载。 10.存取控制将数据成员私有化，并提供相关存取函数，如定义变量foo_及取值函数foo()丶赋值函数set_foo(). 存取函数的定义一般内联在头文件中。 参考继承和函数命名。 11.声明次序在类中使用特定的声明次序：public:在private:之前，成员函数在数据成员(变量)前。 定义次序如下：public:丶protected:丶private:. 每一块中，声明次序一般如下： typedefs和enums； 常量 构造函数 析构函数 成员函数，含静态函数 数据成员，含静态数据成员 宏DISALLOW_COPY_AND_ASSIGN置于private:块之后，作为类的最后部分。参考拷贝构造函数。 .cc文件中函数的定义应尽可能和声明次序一致。 不要将大型函数内联到类的定义中，只有那些没有特定意义的或者性能要求高的，并且是比较短小的函数才能被定义为内联函数。 关于类的结论 不在构造函数内做太多关于逻辑的初始化 编译器提供的默认构造函数不会对变量进行初始化，如果定义了其他构造函数，编译器不再提供，需要编码者自行提供默认构造函数 为避免隐式转换，须将单参数构造函数声明为explicit 为避免拷贝构造函数丶赋值操作的滥用和编译器自动生成，可目前声明其为private且无需实现 仅在作为数据集合时使用struct 组合 &gt; 实现继承 &gt; 接口继承 &gt;私有继承，子类重载的虚函数也要声明virtual关键字，虽然编译器允许不这样做 避免使用多重继承，使用时，除一个基类含有实现外，其他基类均为纯接口 接口类类名以interface为后缀，除提供带实现的虚析构函数丶静态成员函数外，其他均为纯虚函数，不定义非静态数据成员，不提供构造函数，提供的话，声明为protected 为降低复杂性，尽量不重载操作符，模板丶标准类中使用时提供文档说明 存取函数一般内联在头文件中 声明次序：public-&gt;protected-&gt;private 函数体尽量短小丶紧凑，功能单一","tags":[{"name":"笔记","slug":"笔记","permalink":"//louisshark.github.io/tags/笔记/"},{"name":"C++","slug":"C","permalink":"//louisshark.github.io/tags/C/"}]},{"title":"Mrak message parts that should not be translated","date":"2017-07-05T06:41:32.000Z","path":"2017/07/05/Mrak-message-parts-that-should-not-be-translated/","text":"好久没写博客了，最佳一直在看官网的training啊，突然看到一个奇怪的东西，没错就是标题的那个东西，官网是这样子介绍的： Often strings contain contain text that should not be translated into other languages. Common examples might be a piece of code, a placeholder for a value, a special symbol, or a name. As you prepare your strings for translation, look for and mark text that should remain as-is, without translation, so that the translator doesn’t change it. 这几句话大家应该都能看得懂，大概意思就是不让字符串中的代码，占位符，特殊标识或者名字什么的被翻译，而你就要控制他们不被改变。我其实看完有点无语，意思很明显，但是我看不懂啊，于是我把它的示例的string资源打印了一下看看是什么效果(我也是很无聊的)： 123&lt;string name=\"countdown\"&gt; &lt;xliff:g id=\"time\" example=\"5 days&gt;%2$8s&lt;/xliff:g&gt; until holiday&lt;/string&gt; 就是上面这段资源，粘贴到string.xml里面，然后在java中代码动态改变值: 1tv.text(resources.getString(R.string.countdown, \"shark\", \"louis\")) 对了上面这是Kotlin的写法，最近也是在学习这一门大热的语言，这不是重点啊，让我们看看打印的结果： 1louis until holiday 看到没有，我也是试了几下才知道的，%2$8s你们猜到什么意思了吧，没错，2表示的是getString后面的可变参数的位置，意思就是从id后面数起的第二个取代这个占位符，而$8s则表示前面8个空格，并且是字符串 属性id可以随便命名属性example表示举例说明，可以省略%n$ms：代表输出的是字符串，n代表是第几个参数，设置m的值可以在输出之前放置空格%n$md：代表输出的是整数，n代表是第几个参数，设置m的值可以在输出之前放置空格，也可以设为0m,在输出之前放置m个0%n$mf：代表输出的是浮点数，n代表是第几个参数，设置m的值可以控制小数位数，如m=2.2时，输出格式为00.00 贴出官方说法。 注意在String.xml中加命名空间&lt;resources xmlns:xliff=&quot;urn:oasis:names:tc:xliff:document:1.2&quot;&gt; 以上。。 在这其中我发现了一个方法getQuantityString 这个和上面那个很像啊有木有，于是我查了一下资料发现这是对不同语言的单复数的定义不同时的写法，对某些语言的特殊写法吧，这个得和你们的翻译人员问问了。 值 描述 zero 语言需要对数字0进行特殊处理。（比如阿拉伯语） one 语言需要对类似1的数字进行特殊处理。（比如英语和其它大多数语言里的1；在俄语里，任何以1结尾但不以11结尾的数也属于此类型。） two 语言需要对类似2的数字进行特殊处理。（比如威尔士语） few 语言需要对较小数字进行特殊处理（比如捷克语里的2、3、4；或者波兰语里以2、3、4结尾但不是12、13、14的数。） many 语言需要对较大数字进行特殊处理（比如马耳他语里以11-99结尾的数） other 语言不需要对数字进行特殊处理。 看到这个表格我在试一试呗。 1234&lt;plurals name=\"subtitle_plural\"&gt; &lt;item quantity=\"one\"&gt;one crime&lt;/item&gt; &lt;item quantity=\"other\"&gt;%1$s crimes&lt;/item&gt;&lt;/plurals&gt; 在activity中这样写，对比一下效果 12tv.append(resources.getQuantityString(R.plurals.subtitle_plural, 3, 3).toString() + \"\\n\")tv.append(resources.getQuantityString(R.plurals.subtitle_plural, 1, 1)) 结果： 123 crimesone crime 看到这里你也应该明白了，这次的博客内容就这些了，谢谢大家。","tags":[{"name":"官网Guide","slug":"官网Guide","permalink":"//louisshark.github.io/tags/官网Guide/"},{"name":"本地化资源","slug":"本地化资源","permalink":"//louisshark.github.io/tags/本地化资源/"}]},{"title":"AppCompatActivity的作用分析","date":"2017-06-23T09:29:00.000Z","path":"2017/06/23/AppCompatActivity的作用分析/","text":"AppCompatActivity的作用分析 对于v7包下的AppCompatActivity，我是比较晚入的android(并不知道是不是坑)，所以一开始就用的as创建项目就很奇怪为什么我的activity自动继承了AppCompatActivity，不是应该继承Activity吗？Ecm？我仿佛感觉受到了欺骗，于是就对其进行了研究(就是看源码拉)。(因为当时是边看边解析边写的，所以思路可能有点乱，自己再看一遍源码更好，也是学习的一部分) 一开始我就发现了v4 v7 v13等等的support库，然后发现这些库是用来解决兼容问题的，数字分别对应了android的API版本，即分别适配android版本4，7，13以上的app。看完之后发现google程序员为了适配也是良苦用心啊。 从AppCompatActivity源码的onCreate看到这个类初始化的第一步就调用了getDelegate获得了一个代理，并且你会发现下面所有的生命周期的方法都交由这个代理类来实现了，那么这个东西是什么呢？其实就是AppCompatDelegate这个抽象类。 1234567891011121314151617181920212223242526272829 @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; final AppCompatDelegate delegate = getDelegate(); delegate.installViewFactory(); delegate.onCreate(savedInstanceState); if (delegate.applyDayNight() &amp;&amp; mThemeId != 0) &#123; // If DayNight has been applied, we need to re-apply the theme for // the changes to take effect. On API 23+, we should bypass // setTheme(), which will no-op if the theme ID is identical to the // current theme ID. if (Build.VERSION.SDK_INT &gt;= 23) &#123; onApplyThemeResource(getTheme(), mThemeId, false); &#125; else &#123; setTheme(mThemeId); &#125; &#125; super.onCreate(savedInstanceState); &#125;/** * @return The &#123;@link AppCompatDelegate&#125; being used by this Activity. */ @NonNull public AppCompatDelegate getDelegate() &#123; if (mDelegate == null) &#123; mDelegate = AppCompatDelegate.create(this, this); &#125; return mDelegate; &#125; 那么AppCompatDelegate这个类到底做了什么呢？点进去看这个create方法 123public static AppCompatDelegate create(Activity activity, AppCompatCallback callback) &#123; return create(activity, activity.getWindow(), callback);&#125; 然后调用： 123456789101112131415private static AppCompatDelegate create(Context context, Window window, AppCompatCallback callback) &#123; final int sdk = Build.VERSION.SDK_INT; if (BuildCompat.isAtLeastN()) &#123; return new AppCompatDelegateImplN(context, window, callback); &#125; else if (sdk &gt;= 23) &#123; return new AppCompatDelegateImplV23(context, window, callback); &#125; else if (sdk &gt;= 14) &#123; return new AppCompatDelegateImplV14(context, window, callback); &#125; else if (sdk &gt;= 11) &#123; return new AppCompatDelegateImplV11(context, window, callback); &#125; else &#123; return new AppCompatDelegateImplV9(context, window, callback); &#125;&#125; 是不是感觉这些名字有点熟悉呢。 这个方法返回了一些根据版本号的实现类。 下面我将给出这个抽象类的类之间的继承关系： 在as 中使用ctrl + H的快捷键可以很快的看到类之间的继承图。 发现他们之间相互继承，于是开始看V9的源码，找到了一个可疑的方法： 12345678910111213141516171819202122232425262728293031323334/** 这个方法会(invoke) &#123;当我们使用自己的layoutInflater的factory的时候&#125; */ @Override public View createView(View parent, final String name, @NonNull Context context, @NonNull AttributeSet attrs) &#123; final boolean isPre21 = Build.VERSION.SDK_INT &lt; 21; if (mAppCompatViewInflater == null) &#123; mAppCompatViewInflater = new AppCompatViewInflater(); &#125; // We only want the View to inherit its context if we're running pre-v21 final boolean inheritContext = isPre21 &amp;&amp; shouldInheritContext((ViewParent) parent); return mAppCompatViewInflater.createView(parent, name, context, attrs, inheritContext, isPre21, /* Only read android:theme pre-L (L+ handles this anyway) */ true, /* Read read app:theme as a fallback at all times for legacy reasons */ VectorEnabledTintResources.shouldBeUsed() /* Only tint wrap the context if enabled */ ); &#125; @Override public void installViewFactory() &#123; LayoutInflater layoutInflater = LayoutInflater.from(mContext); if (layoutInflater.getFactory() == null) &#123; LayoutInflaterCompat.setFactory(layoutInflater, this); &#125; else &#123; if (!(LayoutInflaterCompat.getFactory(layoutInflater) instanceof AppCompatDelegateImplV9)) &#123; Log.i(TAG, \"The Activity's LayoutInflater already has a Factory installed\" + \" so we can not install AppCompat's\"); &#125; &#125; &#125; 突然想起来一句话，兼容问题其实就是着色问题，AppCompatDelegate 的工作就是涂色。发现这个方法在AppCompatDelegate里面定义的，别问我怎么找到的，你在V9这个类看到1000多行代码的时候找到了，然后我跑回去看AppCompatDelegate这个类里面的方法。 12345678910111213141516171819202122232425262728293031/** * Installs AppCompat's &#123;@link android.view.LayoutInflater&#125; Factory so that it can replace * the framework widgets with compatible tinted versions. This should be called before * &#123;@code super.onCreate()&#125; as so: * &lt;pre class=\"prettyprint\"&gt; * protected void onCreate(Bundle savedInstanceState) &#123; * getDelegate().installViewFactory(); * getDelegate().onCreate(savedInstanceState); * super.onCreate(savedInstanceState); * * // ... * &#125; * &lt;/pre&gt; * If you are using your own &#123;@link android.view.LayoutInflater.Factory Factory&#125; or * &#123;@link android.view.LayoutInflater.Factory2 Factory2&#125; then you can omit this call, and instead call * &#123;@link #createView(android.view.View, String, android.content.Context, android.util.AttributeSet)&#125; * from your factory to return any compatible widgets. */ public abstract void installViewFactory(); /** * This should be called from a * &#123;@link android.view.LayoutInflater.Factory2 LayoutInflater.Factory2&#125; in order * to return tint-aware widgets. * &lt;p&gt; * This is only needed if you are using your own * &#123;@link android.view.LayoutInflater LayoutInflater&#125; factory, and have therefore not * installed the default factory via &#123;@link #installViewFactory()&#125;. */ public abstract View createView(@Nullable View parent, String name, @NonNull Context context, @NonNull AttributeSet attrs); 看到上面的注释我突然顿悟了，找了半天的在哪里设置的layoutInflater的factory，原来是这样子，于是又去AppCompatActivity瞅了一眼： 12345protected void onCreate(@Nullable Bundle savedInstanceState) &#123; final AppCompatDelegate delegate = getDelegate(); delegate.installViewFactory(); delegate.onCreate(savedInstanceState); &#125; 发现onCreate方法里果然有这句话，installViewFactory()；这个方法就是给The Activity’s LayoutInflater设置一个自己的factory，于是就会调用createView这个方法 注意createView里面的这句话： 12345return mAppCompatViewInflater.createView(parent, name, context, attrs, inheritContext, isPre21, /* Only read android:theme pre-L (L+ handles this anyway) */ true, /* Read read app:theme as a fallback at all times for legacy reasons */ VectorEnabledTintResources.shouldBeUsed() /* Only tint wrap the context if enabled */ ); 于是跑到AppCompatViewInflater的createView方法看，终于找到了： 123456789101112131415161718192021222324252627282930313233343536373839404142// We need to 'inject' our tint aware Views in place of the standard framework versions switch (name) &#123; case \"TextView\": view = new AppCompatTextView(context, attrs); break; case \"ImageView\": view = new AppCompatImageView(context, attrs); break; case \"Button\": view = new AppCompatButton(context, attrs); break; case \"EditText\": view = new AppCompatEditText(context, attrs); break; case \"Spinner\": view = new AppCompatSpinner(context, attrs); break; case \"ImageButton\": view = new AppCompatImageButton(context, attrs); break; case \"CheckBox\": view = new AppCompatCheckBox(context, attrs); break; case \"RadioButton\": view = new AppCompatRadioButton(context, attrs); break; case \"CheckedTextView\": view = new AppCompatCheckedTextView(context, attrs); break; case \"AutoCompleteTextView\": view = new AppCompatAutoCompleteTextView(context, attrs); break; case \"MultiAutoCompleteTextView\": view = new AppCompatMultiAutoCompleteTextView(context, attrs); break; case \"RatingBar\": view = new AppCompatRatingBar(context, attrs); break; case \"SeekBar\": view = new AppCompatSeekBar(context, attrs); break; &#125; 原来在activity的oncreate一开始创建的时候，系统就自动帮我们把这些色调给我们换掉了所以你写在XML的控件，都会被换成AppCompat开头的兼容性的控件，当然前提是你要继承AppCompatActivity，这就是系统为我们所做的适配了，请注意，AppCompatViewInflater也给我们提供了一个热换肤的思路，下次有时间再说吧。 总结起来，这个兼容其实就是偷梁换柱，而且看源码一定不能被细枝末节影响，像我一样，如果我能做点笔记，而不是草率的开始，应该过程会更加的轻松。","tags":[{"name":"android","slug":"android","permalink":"//louisshark.github.io/tags/android/"},{"name":"源码分析","slug":"源码分析","permalink":"//louisshark.github.io/tags/源码分析/"}]},{"title":"滑动冲突的解决方式","date":"2017-06-14T03:04:10.000Z","path":"2017/06/14/滑动冲突的解决方式/","text":"外部拦截法 即指点击事件都先经过父容器的拦截处理，如果父容器需要此事件就拦截，如果不需要此事件就不拦截，这样就可以解决滑动冲突的问题，这种方法比较符合点击事件的分发机制。外部拦截法要重写父容器的onInterceptTouchEvent方法，并在内部做相应的拦截。伪代码如下： 1234567891011121314151617181920212223242526@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) &#123; boolean intercepted = false; int x = (int) ev.getX(); int y = (int) ev.getY(); switch (ev.getAction()) &#123; case MotionEvent.ACTION_DOWN: intercepted = false; break; case MotionEvent.ACTION_MOVE: if (父容器需要当前点击事件)&#123; intercepted = true; &#125; else &#123; intercepted = false; &#125; break; case MotionEvent.ACTION_UP: intercepted = false; break; default: break; &#125; mLastXIntercept = x; mLastYIntercept = y; return intercepted;&#125; 上述代码是外部拦截法的典型逻辑，针对不同的滑动冲突，只需要修改父容器需要当前点击事件这个条件即可，其他均不需并且也不能修改。 对上述代码进行讲解： ​ ACTION_DOWN事件返回false，因为父容器拦截了down事件，后续的action_move和action_up事件都会直接 交由父容器处理，事件无法传递给子元素.​ ACTION_MOVE事件，可以根据需要来决定是否拦截，如果父容器拦截就返回true，不拦截就返回false。​ ACTION_UP事件，必须返回false，因为up事件本身并没有多大的意义。 考虑一种情况，假设事件交由子元素处理，如果父容器在ACTION_UP时返回了true，就会导致子元素无法接收到ACTION_UP事件，这个时候子元素中的onclick事件就无法触发，但是父容器比较特殊，一旦它开始拦截任何一个事件，那么后续的事件都会交由它来处理，而ACTION_UP作为最后一个事件也必定可以传递给父容器，即使父容器的onInterceptTouchEvent方法在ACTION_UP时返回了false. 内部拦截法 内部拦截法是指父容器不拦截任何事件，所有的事件都传递给子元素，如果子元素需要此事件就直接消耗掉，否则就交由父容器进行处理，这种方法和android中的事件分发机制就不一样，需要配合requestDisallowInterceptTouchEvent方法才能正常工作，使用起来比外部拦截法稍显复杂。伪代码如下： 1234567891011121314151617181920212223242526@Overridepublic boolean dispatchTouchEvent(MotionEvent event) &#123; int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: parent.requestDisallowInterceptTouchEvent(true); break; case MotionEvent.ACTION_MOVE: int deltaX = x - mLastX; int deltaY = y - mLastY; if (父容器需要此类点击事件) &#123; parent.requestDisallowInterceptTouchEvent(false); &#125; break; case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: break; default: break; &#125; mLastX = x; mLastY = y; return super.dispatchTouchEvent(event);&#125; 上述代码是内部拦截法的典型代码，当面对不同的滑动策略时只需要修改里面1的条件即可，其他不需要做改动也不需要做改动。除了子元素需要做处理以外，父元素也要默认拦截除了ACTION_DOWN以外的其他事件，这样当子元素调用parent.requestDisallowInterceptTouchEvent(false)方法时，父元素才能继续拦截所需的事件。 为什么父容器不能拦截ACTION_DOWN事件呢，因为这个事件不受FLAG_DISALLOW_INTERCEPT这个标记位的控制，所以一旦父容器拦截ACTION_DOWN事件了，那么所有的事件都无法传递到子元素去，这样内部拦截法就无法起作用了。 父元素的修改如下： 12345678910@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) &#123; int action = ev.getAction(); if (action == MotionEvent.ACTION_DOWN) &#123; return false; &#125; else &#123; return true; &#125;&#125; ​","tags":[{"name":"自定义view","slug":"自定义view","permalink":"//louisshark.github.io/tags/自定义view/"},{"name":"滑动冲突","slug":"滑动冲突","permalink":"//louisshark.github.io/tags/滑动冲突/"},{"name":"事件分发","slug":"事件分发","permalink":"//louisshark.github.io/tags/事件分发/"}]},{"title":"使用SVG来实现复杂的自定义View","date":"2017-06-02T01:48:53.000Z","path":"2017/06/02/使用SVG来实现复杂的自定义View/","text":"最近发现可以用SVG来实习非常复杂的自定义View，可以说是非常的厉害了。只要你看到不想做的很复杂的设计图，你就让美工妹子给你来一张SVG吧，还可以趁机和她聊下天。 我们就来画一个可交互的中国台湾地图吧，首先我们来理一下做这种自定义View的步骤。 下载含有中国地图的 SVG 用此 网站 将svg资源转换成相应的 Android代码 利用Xml解析SVG的代码 封装成javaBean 最重要的得到Path 重写OnDraw方法 利用Path绘制中国地图 重写OnTouchEvent方法，记录手指触摸位置，判断这个位置是否坐落在某个省份上 对了，地图资源可以在这里 下载。开始写代码吧。 项目地址点这里可以看源码。 前两步不需要我如何说了吧，可以把转化后的android代码，放入res/raw目录下，接下来开始第三步： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private void parseXMLWithPull() &#123; InputStream inputStream = null; try &#123; inputStream = context.getResources().openRawResource(R.raw.taiwanhigh); XmlPullParserFactory factory = XmlPullParserFactory.newInstance(); factory.setNamespaceAware(true); XmlPullParser xmlPullParser = factory.newPullParser(); xmlPullParser.setInput(inputStream, \"UTF-8\"); int eventType = xmlPullParser.getEventType(); ProvinceItem item = null; while (eventType != XmlPullParser.END_DOCUMENT) &#123; String nodeName = xmlPullParser.getName(); switch (eventType) &#123; //开始解析某个节点 case XmlPullParser.START_DOCUMENT: itemList = new ArrayList&lt;&gt;(); break; case XmlPullParser.START_TAG: if (\"path\".equals(nodeName)) &#123; String pathData = xmlPullParser.getAttributeValue(\"http://schemas.android.com/apk/res/android\", \"pathData\"); Path path = PathParser.createPathFromPathData(pathData); item = new ProvinceItem(path); &#125; break; case XmlPullParser.END_TAG: if (nodeName.equalsIgnoreCase(\"path\") &amp;&amp; item != null) &#123; assert itemList != null; itemList.add(item); item = null; handler.sendEmptyMessage(PARSE_END); &#125; break; default: break; &#125; eventType = xmlPullParser.next(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (inputStream != null) &#123; try &#123; inputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; xml解析写的非常随便，如果有需要修改的请自行修改，这里主要的是将解析出来的path标签下的pathData，然后使用封装好的PathParser(这个类大家可以自己去搜索下载)来将pathData封装成path，然后将path传入ProvinceItem类生成java bean类。下面我们来看一下这个Bean类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/* 路径 */ private Path path; /* 绘制颜色 */ private int drawColor; public ProvinceItem(Path path) &#123; this.path = path; &#125; /** * 自绘 * @param canvas * @param paint * @param isSelect */ public void draw(Canvas canvas, Paint paint, boolean isSelect) &#123; if (isSelect) &#123; //绘制背景 paint.setStrokeWidth(2); paint.setColor(Color.BLACK); paint.setStyle(Paint.Style.FILL); paint.setShadowLayer(8, 0, 0, 0xffffffff); canvas.drawPath(path, paint); //绘制省份 paint.clearShadowLayer(); paint.setColor(drawColor); paint.setStyle(Paint.Style.FILL); paint.setStrokeWidth(2); canvas.drawPath(path, paint); &#125; else &#123; //没有被选择的时候绘制内容 paint.clearShadowLayer(); paint.setColor(drawColor); paint.setStyle(Paint.Style.FILL); paint.setStrokeWidth(1); canvas.drawPath(path, paint); //选择的时候绘制边界线 paint.setStyle(Paint.Style.STROKE); paint.setColor(0XFFEEEEEE); canvas.drawPath(path, paint); &#125; &#125; /* 判断是否点击了省份 */ public boolean isTouch(int x, int y) &#123; RectF rectF = new RectF(); //就是用path的四个点生成一个rectf path.computeBounds(rectF, true); Region region = new Region(); //setPath 就是用path在region里面剪切出一个区域 region.setPath(path, new Region((int) rectF.left, (int) rectF.top, (int) rectF.right, (int) rectF.bottom)); return region.contains(x, y); &#125; 这个类主要就是两个方法，draw方法和isTouch方法，下面来说这两个方法的作用： drawdraw方法主要是传递三个参数来进行自绘： canvas 画板 paint 画笔 isSelect 是否被选中 因为这个方法用来处理被点击时界面的变化，未选中和被选中的效果是不一样的。 此处可以自己来随便写。 isTouch这个方法判断这个区域是否被选中，当然也可以有其他的方法来判断是否被点击，这里提供一种思路，主要是region里面的setPath方法，我们点进去源码看一下 12345678910&gt; /**&gt; * Set the region to the area described by the path and clip.&gt; * Return true if the resulting region is non-empty. This produces a region&gt; * that is identical to the pixels that would be drawn by the path&gt; * (with no antialiasing).&gt; */&gt; public boolean setPath(Path path, Region clip) &#123;&gt; return nativeSetPath(mNativeRegion, path.readOnlyNI(), clip.mNativeRegion);&gt; &#125;&gt; &gt; 大概的意思就是用这个path在region裁剪出一个region，这个区域就是省份的区域，是不规则的。 解析完了之后就是第四步了，重写ondraw。 12345678910111213141516171819@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); if (itemList != null) &#123; canvas.save(); canvas.scale(SCALE_FATOR, SCALE_FATOR); for (ProvinceItem item : itemList) &#123; //绘制未被选中 if (item != selectedItem) &#123; item.draw(canvas, paint, false); &#125; &#125; //绘制选择的 if (selectedItem != null) &#123; selectedItem.draw(canvas, paint, true); &#125; &#125;&#125; 这里就是很简单的绘制。 第五步。重写onTouchEvent方法。 1234567891011121314151617181920212223242526272829303132333435363738 @Override public boolean onTouchEvent(MotionEvent event) &#123; //将事件转交 return gestureDetectorCompat.onTouchEvent(event); &#125;private void init(Context context) &#123; gestureDetectorCompat = new GestureDetectorCompat(context, new GestureDetector.SimpleOnGestureListener() &#123; @Override public boolean onDown(MotionEvent e) &#123; handlerTouch(e.getX(), e.getY()); return super.onDown(e); &#125; &#125;); &#125; /** * 处理触摸事件的方法 * @param x * @param y */ private void handlerTouch(float x, float y) &#123; if (itemList != null) &#123; ProvinceItem temp = null; for (ProvinceItem item : itemList) &#123; //要除以一个放大系数 if (item.isTouch((int) (x / SCALE_FATOR), (int) (y / SCALE_FATOR))) &#123; temp = item; break; &#125; &#125; if (temp != null) &#123; selectedItem = temp; Toast.makeText(context, \"You click me OVO\", Toast.LENGTH_SHORT).show(); postInvalidate(); &#125; &#125; &#125; 主要就是将down事件转交给gestureDetector来处理，然后写了处理触摸的方法，注意判断点击的xy值需要除以一个放大系数，因为前面放大了canvas，不然会点不到。 好了，以上就是主要的内容了，有什么想看的可以去github看源码，这也是我的学习笔记，发现svg制作复杂的自定义view真的是摔锅神器啊，开玩笑，是大大加快了开发效率。。。","tags":[{"name":"SVG","slug":"SVG","permalink":"//louisshark.github.io/tags/SVG/"},{"name":"自定义view","slug":"自定义view","permalink":"//louisshark.github.io/tags/自定义view/"}]},{"title":"UI事件传递","date":"2017-05-08T03:46:30.000Z","path":"2017/05/08/UI事件传递/","text":"一些事件传递机制的结论事件传递伪代码：123456789public boolean dispatchTouchEvent(MotionEvent ev) &#123; boolean consume = false; if (onInterceptTouchEvent(ev)) &#123; consume = onTouchEvent(ev); &#125; else &#123; consume = child.dispatchTouchEvent(ev); &#125; return consume;&#125; 一个时间序列是指从手指接触屏幕的那一刻起，到手指离开屏幕的那一刻结束。 正常情况下，一个事件序列只能被一个view拦截且消耗。但可以通过特殊手段做到，比如一个view将本该自己处理的事件通过onTouchEvent强行传递给其他View处理。 某个view一旦决定拦截，那么这一个事件序列都只能由这个view来处理（如果这个事件序列可以传递给他的话），并且它的onInterceptTouchEvent 不会再被调用。 某个view一旦开始处理事件，如果他不消耗ACTION_DOWN 事件(onTouchEvent返回了false)，那么同一事件序列中的其他事件都不会在交给他来处理，并且事件将重新交由它的父元素去处理，即父元素的onTouchEvent会被调用。意思是事件一旦交给一个view处理，那么他必须消耗掉，否则同一事件序列中剩下的事件就不再交给他处理了。 如果View 不消耗除 ACTION_DOWN以外的其他事件，那么这个点击事件会消失，此时父元素的onTouchEvent并不会调用,并且当前View可以持续收到后续的事件，最终这些消失的点击事件会传递给Activity处理。 ViewGroup默认不拦截任何事件。 View 没有onInterceptTouchEvent方法，一旦有事件传递给他，那么它的onTouchEvent方法就会被调用。 View的onTouchEvent默认都会消耗事件（返回true），除非它是不可点击的(clickable和longClickable 同时为false)。 View的enable属性不影响onTouchEvent的默认返回值。哪怕一个view是disable状态的，只要他的clickable或者longClickable有一个为true，那么它的onTouchEvent就返回true。 onClick会发生的前提是当前view是可点击的，并且他收到了down和up事件。 事件传递过程是由外向内的，即事件总是先传递给父元素，然后在由父元素分发给子View，通过requestDisallowInterceptTouchEvent可以在子元素中干预父元素的事件分发过程，但是ACTION_DOWN除外。","tags":[{"name":"UI事件传递","slug":"UI事件传递","permalink":"//louisshark.github.io/tags/UI事件传递/"},{"name":"android开发艺术探索","slug":"android开发艺术探索","permalink":"//louisshark.github.io/tags/android开发艺术探索/"}]},{"title":"ffmpeg知识点","date":"2017-05-03T16:00:00.000Z","path":"2017/05/04/ffmpeg基础知识和win编译/","text":"libavcodec: 用于各种类型声音/图像编解码 libavutil: 包含一些公共的工具函数 libavformat: 包含多种多媒体容器格式的封装丶解封装工具 libswscale: 用于视频场景的比例缩放丶色彩映射转换 libpostproc: 用于后期效果处理 libavdevice: 用于音视频数据采集和渲染等功能的设备相关 ibswresample: 用于音频重采样和格式转换等功能 libavfilter: 包含多媒体处理常用的滤镜功能 ffmpeg的官方网站是：http://ffmpeg.org/编译好的windows可用版本的下载地址（和官网保持同步）：http://ffmpeg.zeranoe.com/builds/ 该网站中的FFMPEG分为3个版本：Static，Shared，Dev。 前两个版本都可以直接在命令行使用： Static：只有3个应用程序：ffmpeg.exe,ffplay.exe,ffprobe.exe。每个exe的体积都很大，相关的Dll都已经被编译到exe里面去了。Shared : 除了上面那三个exe之外，还有一些Dll，比如avcodec-54.dll之类的。shared里面的exe体积很小，他们运行时到相应的Dll中调用功能。Dev : 用于开发，里面包含了库文件xxx.lib以及头文件xxx.h，这个版本不包含exe文件。 ffmpeg :该项目提供的一个工具，可用于格式转换丶解码或电视卡即时编译等。ffprobe : ffprobe是用于查看文件格式的应用程序。ffplay ：是一个简单的播放器，使用ffmpeg库解析和解码，通过SDL显示ffserver ：一个HTTP多媒体即时广播串流服务器。 常用命令集 获取视频的信息ffmpeg -i video.avi 将图片序列合成视频ffmpeg -f image2 -i image%d.jpg video.mpg上面的命令会把当前目录下的图片（名字如：image1.jpg, image2.jpg等..）合成video.mpg 将视频分解成图片序列ffmpeg -i video.mpg image%d.jpg上面的命令会生成image1.jpg,image2.jpg…支持的图片格式有：PGM,PPM,PAM,PGMYUV,JPEG,GIF,PNG,TIFF,SGI 为视频重新编码以适合在ipod/iphone上播放ffmpeg -i source_video.avi input -acodec aac -ab 128kb -vcodec mpeg4 -b 1200kb -mbd 2 -flags +4mv+trell -aic 2 -cmp 2 -subcmp 2 -s 320x180 -title X final_video.mp4说明： 1234567- 源视频：source_vidro.avi- 音频编码：aac- 音频位率：128kb/s- 视频编码：mpeg4- 视频位率：1200kb/s- 视频尺寸：320 X 180- 生成的视频：final_video.mp4 为视频重新编码以适合在PSP上播放ffmpeg -i source_video.avi -b 300 -s 320x240 -vcodec xvid -ab 32 -ar 24000 -acodec aac final_video.np4说明： 1234567+ 源视频：source_video.avi+ 音频编码：aac+ 音频位率：32kb/s+ 视频编码：xvid+ 视频位率：1200kb/s+ 视频尺寸：320 X 180+ 生成的视频：final_video.mp4 从视频抽出声音。并存为Mp3ffmpeg -i source_video.avi -vn -ar44100 -ac 2 -ab 192 -f mp3 sound.mp3说明： 1234* 源视频：source_video.avi* 音频位率：192kb/s* 输出格式：mp3* 生成的声音：sound.mp3 将wav文件转成Mp3ffmpeg -i son_origine.avi -vn -ar 44100 -ac 2 -ab 192 -f mp3 son_final.mp3 将.avi视频转成.mpgffmpeg -i video_origine.avi video_finale.mpg 将.mpg转成.aviffmpeg -i video_origine.mpg video_finale.avi 将.avi转成gif动画（未压缩）ffmpeg -i video_origine.avi gif_anime.gif 合成视频和音频ffmpeg -i son.wav -i video_origine.avi video_finale.mpg 将.avi转成.flvffmpeg -i video_origine.avi -ab 56 -ar 44100 -b 200 -r 15 -s 320x240 -f flv video_finale.flv 将.avi转成dvffmpeg -i video_origine.avi -s pal -r pal -aspect 4:3 -ar 48000 -ac 2 video_finale.dv或ffmpeg -i video_origine.avi -target pal-dv video_finale.dv 将.avi压缩成divxffmpeg -i video_origine.avi -s 320x240 -vcodec msmpeg4v2 video_finale.avi 将Ogg Theora 压缩成Mpeg dvdffmpeg -i film_sortie_cinelerra.ogm -s 720x576 -vcodec mpeg2video -acodec mp3 film_terminate.mpg 将.avi压缩成SVCD mpeg2NTSC格式：ffmpeg -i video_origine.avi -target ntsc-svcd video_finale.mpgPAL格式：ffmpeg -i video_origine.avi -target pal-svcd video_finale.mpg 将.avi压缩成VCD mpeg2NTSC格式：ffmpeg -i video_origine.avi -target ntsc-vcd video_finale.mpgPAL格式：ffmpeg -i video_origine.avi -traget pal-vcd video_finale.mpg 多通道编码ffmpeg -i fichierentree -pass 2 -passlogfile ffmpeg2pass fichiersortie-2 从flv提取mp3ffmpeg -i source.flv -ab 128k dest.mp3 ##win下编译ffmpeg3.3 下载安装MinGW 下载yasm ffmpeg 编辑ffmpeg文件夹下面的configure文件，找到123456789SLIBNAME_WITH_MAJOR='$(SLIBNAME).$(LIBMAJOR)'LIB_INSTALL_EXTRA_CMD='$$(RANLIB) \"$(LIBDIR)/$(LIBNAME)\"'SLIB_INSTALL_NAME='$(SLIBNAME_WITH_VERSION)'SLIB_INSTALL_LINKS='$(SLIBNAME_WITH_MAJOR) $(SLIBNAME)'将其修改成：SLIBNAME_WITH_MAJOR='$(SLIBPREF)$(FULLNAME)-$(LIBMAJOR)$(SLIBSUF)'LIB_INSTALL_EXTRA_CMD='$$(RANLIB) \"$(LIBDIR)/$(LIBNAME)\"'SLIB_INSTALL_NAME='$(SLIBNAME_WITH_MAJOR)'SLIB_INSTALL_LINKS='$(SLIBNAME)' 新建build_android.sh文件注意：要根据环境配置的前四项，且每行末尾不能有空格。export TMPDIR,NDK,SYSROOT,TOOLCHAIN-cross-prefix 一定有12345678910111213141516171819202122232425262728293031323334#!/bin/bashexport TMPDIR=\"D:\\ffmpeg\\tmp\"NDK=D:\\/sdk\\/ndk-bundleSYSROOT=$NDK/platforms\\/android-24\\/arch-arm/TOOLCHAIN=$NDK/toolchains/arm-linux-androideabi-4.9/prebuilt/windows-x86_64function build_one &#123; ./configure \\ --prefix=$PREFIX \\ --enable-shared \\ --disable-static \\ --disable-doc \\ --disable-ffmpeg \\ --disable-ffplay \\ --disable-ffprobe \\ --disable-ffserver \\ --disable-avdevice \\ --disable-doc \\ --disable-symver \\ --cross-prefix=$TOOLCHAIN/bin/arm-linux-androideabi- \\ --target-os=linux \\ --arch=arm \\ --enable-cross-compile \\ --sysroot=$SYSROOT \\ --extra-cflags=\"-Os -fpic $ADDI_CFLAGS\" \\ --extra-ldflags=\"$ADDI_LDFLAGS\" \\ $ADDITIONAL_CONFIGURE_FLAG make clean make make install &#125; CPU=arm PREFIX=$(pwd)/android/$CPU ADDI_CFLAGS=\"-marm\" build_one 然后在MinGW中cd进ffmpeg目录。命令： chomd 777 ./build_android.sh./build_android.sh 开始编译 编译完成后在FFmpeg下会多一个Android文件夹。","tags":[{"name":"android","slug":"android","permalink":"//louisshark.github.io/tags/android/"},{"name":"ffmpeg","slug":"ffmpeg","permalink":"//louisshark.github.io/tags/ffmpeg/"}]},{"title":"手动实现arraylist和hashmap","date":"2017-05-02T08:37:26.000Z","path":"2017/05/02/手动实现arraylist和hashmap/","text":"这是第一篇博客，我准备先将最近学习的笔记记录下来，数据结构最基础也最难吧，大佬就别看了。。。 Arraylist public class LouisArraylist&lt;E&gt; { int size; Object[] array; private static final int MIN_CAPACITY_INCREMENT = 12; public LouisArraylist(int capacity){ if(capacity&lt;0){ throw new IllegalArgumentException(); } array = new Object[capacity]; } public LouisArraylist(){ array = new Object[0]; } public LouisArraylist(Collection&lt;? extends E&gt; collection){ Object[] a = collection.toArray(); if(a.getClass()!=Object[].class){ Object[] newArray = new Object[a.length]; System.arraycopy(a, 0, newArray, 0, a.length); a = newArray; } array = a; size = a.length; } /** * 扩容 * */ private static int newCapacity(int currentCapacity){ int increment = (currentCapacity&lt;MIN_CAPACITY_INCREMENT/2)?MIN_CAPACITY_INCREMENT :currentCapacity&gt;&gt;1; return currentCapacity+increment; } /** * 增加 */ public boolean add(E object){ Object[] a = array; int s = size; if(s == a.length){ //需要扩容了 Object[] newArray = new Object[newCapacity(s)]; System.arraycopy(a, 0, newArray, 0, s); array = a = newArray; } a[s] = object; size = s + 1; return true; } public int size(){ return size; } public boolean isEmpty(){ return size==0; } /** * 查找首次出现元素的下标 */ public int indexOf(Object object){ Object[] a = array; int s = size; if(object!=null){ for(int i = 0;i&lt;s;i++){ if(object.equals(a[i])){ return i; } } }else{ for(int i = 0;i&lt;s;i++){ if(a[i] == null){ return i; } } } return -1; } public int lastIndexOf(Object object){ Object[] a = array; int s = size; if(object!=null){ for(int i = s -1;i &gt;= 0;i--){ if(object.equals(a[i])){ return i; } } }else{ for(int i = s -1;i &gt;= 0;i--){ if(a[i] == null){ return i; } } } return -1; } /** * 删除某个元素 */ public E remove(int index){ Object [] a = array; int s = size; if(index &gt;= s){ throw new IndexOutOfBoundsException(); } E e = (E) a[index]; System.arraycopy(a, index+1, a, index, --s-index); a[s] = null; size = s; return e; } /** * 删除某个元素 */ public boolean remove(Object object){ Object[] a = array; int s = size; if (object == null) { for (int i = 0; i &lt; size; i++) { if (a[i] == null) { remove(i); return true; } } } else { for (int i = 0; i &lt; size; i++) { if (a[i].equals(object)) { remove(i); return true; } } } return false; } public E set(int index,E object){ Object[] a = array; if(index&gt;size){ throw new IndexOutOfBoundsException(); } E e = (E) a[index]; a[index] = object; return e; } /** * 获取 */ public E get(int index){ Object[] a = array; if(index&gt;size){ throw new IndexOutOfBoundsException(); } E e = (E) a[index]; return e; } } 代码已经说明的很清楚了，我就不多说什么了，知道底层是数组实现就ok了 HashMap public class LouisHashMap { private int size; private static final int MINIMUN_CAPACITY = 1 &lt;&lt; 2; private static final int MAXNIMUN_CAPACITY = 1 &lt;&lt; 30; //阈值 private int threshhold; //用于强制扩容,因为比minimun还小 private static final Map.Entry[] EMPTY_TABLE = new LouisEntry[MINIMUN_CAPACITY &gt;&gt; 1]; private LouisEntry&lt;K, V&gt;[] table; //核心数组 LouisEntry&lt;K, V&gt; entryOrNullKey; //空键entry public LouisHashMap() { table = (LouisEntry&lt;K, V&gt;[]) EMPTY_TABLE; threshhold = -1; } public LouisHashMap(int capacity) { if (capacity &lt; 0) { throw new IllegalArgumentException(&quot;capacity :&quot; + capacity); } else if (capacity == 0) { table = (LouisEntry&lt;K, V&gt;[]) EMPTY_TABLE; threshhold = -1; return; } else if (capacity &lt; MINIMUN_CAPACITY &amp;&amp; capacity &gt; 0){ capacity = MINIMUN_CAPACITY; } else if (capacity &gt; MAXNIMUN_CAPACITY) { capacity = MAXNIMUN_CAPACITY; } else { capacity = roundUpToPowerOfTwo(capacity); } makeTable(capacity); } /** * 添加 * @param key * @param value * @return */ public V put(K key, V value) { if (key == null) { return putValueForNullKey(value); } int hash = sencondaryHash(key.hashCode()); LouisEntry&lt;K, V&gt;[] tab = table; //将一个很散列的值 位与一个索引大小，会取得0~索引的值 int index = hash &amp; (table.length - 1); //先检查是否存在相同的键 for (LouisEntry&lt;K, V&gt; e = tab[index]; e != null; e = e.next) { //键相同hash值一定相同， hash相同键不一定相同 if (e.hash == hash &amp;&amp; key.equals(e.getKey())) { V oldValue = e.getValue(); e.setValue(value); return oldValue; } } //没有覆盖直接插入元素 if (size++ &gt; threshhold) { //创建一个新的容量的数组 tab = doubleCapacity(); index = hash &amp; (tab.length - 1); } addNewEntry(key, value, hash, index); return null; } private void addNewEntry(K key, V value, int hash, int index) { //将新创建的entry加在链表头，一句代码解决两个事情，放头部，放容易查询也容易 table[index] = new LouisEntry&lt;&gt;(key, value, hash, table[index]); } /** * get * @return */ public V get(Object key) { if (key == null) { LouisEntry&lt;K, V&gt; e = entryOrNullKey; return e == null ? null : e.getValue(); } int hash = sencondaryHash(key.hashCode()); LouisEntry&lt;K, V&gt;[] tab = table; int index = hash &amp; (tab.length - 1); for (LouisEntry&lt;K, V&gt; entry = tab[index]; entry != null; entry = entry.next) { K ekey = entry.key; //比较时，先比较对象值是否相等，在比较属性值是否相等，增加效率 if (ekey == key || (entry.hash == hash &amp;&amp; key.equals(ekey))) { return entry.value; } } return null; } /** * 双倍扩容 * @return */ private LouisEntry&lt;K, V&gt;[] doubleCapacity() { LouisEntry&lt;K, V&gt;[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXNIMUN_CAPACITY) { return oldTable; } //2的幂次方 int newCapacity = oldCapacity &lt;&lt; 1; System.out.println(&quot;扩容：&quot; + size); LouisEntry&lt;K, V&gt;[] newTable = makeTable(newCapacity); if (size == 0) { return newTable; } //开始重新散列 for (int j = 0; j &lt; oldTable.length; j++) { LouisEntry&lt;K, V&gt; e = oldTable[j]; //拿到每个键值对 if (e == null) { continue; //因为每个索引不一定有值，hash } // 与上面 int index = hash &amp; (table.length - 1);会出现两组数据，一种还在远处，一种去到length的位置 int highBit = e.hash &amp; oldCapacity; LouisEntry&lt;K, V&gt; broken = null; //位或 运算最多是原值的两倍，重新一次散列 newTable[j | highBit] = e; for (LouisEntry&lt;K, V&gt; n = e.next; n != null; e = n, n = n.next) { //n 为当前遍历的元素， e为前一个 int nextHighBit = n.hash &amp; oldCapacity; if (nextHighBit != highBit) { if (broken == null) { int nextNewIndex = j | nextHighBit; //新的索引的位置 newTable[nextNewIndex] = n; } else { broken.next = n; } broken = e; highBit = nextHighBit; } } if (broken != null) { broken.next = null; } } return newTable; } /** * hashMap键的hash算法 * @param h * @return */ private int sencondaryHash(int h) { h ^= (h&gt;&gt;&gt;20)^(h&gt;&gt;&gt;12); return h^(h&gt;&gt;&gt;7)^(h&gt;&gt;&gt;4); } /** * 放空键的键值对 * @param value * @return */ private V putValueForNullKey(V value) { LouisEntry&lt;K, V&gt; entry = entryOrNullKey; if (entry == null) { addNewEntryForNullKey(value); size++; return null; } else{ V oldValue = entry.getValue(); entry.setValue(value); return oldValue; } } private void addNewEntryForNullKey(V value) { entryOrNullKey = new LouisEntry&lt;K, V&gt;(null, value, 0, null); } /** * 根据容量创建核心数组 * @param capacity */ private LouisEntry&lt;K, V&gt;[] makeTable(int capacity) { LouisEntry&lt;K, V&gt;[] newTable = new LouisEntry[capacity]; table = newTable; threshhold = (capacity &gt;&gt;&gt; 2) + (capacity &gt;&gt;&gt; 1); return newTable; } private int roundUpToPowerOfTwo(int i) { i--; i |= i &gt;&gt;&gt; 1; // i = i | (i &gt;&gt;&gt; 1) 让所有的位都变成 1 ， 最后在加 1，就可以被2整除 i |= i &gt;&gt;&gt; 2; i |= i &gt;&gt;&gt; 4; i |= i &gt;&gt;&gt; 8; i |= i &gt;&gt;&gt; 16; return i + 1; } public int getSize() { return size; } /** * 键值对类 * @param &lt;K&gt; * @param &lt;V&gt; */ static class LouisEntry&lt;K, V&gt; implements Map.Entry&lt;K, V&gt; { final int hash; final K key; //此处用final 只赋值一次，因为key是唯一的 V value; LouisEntry&lt;K, V&gt; next; public LouisEntry(K key, V value, int hash, LouisEntry&lt;K, V&gt; next) { this.key = key; this.value = value; this.hash = hash; this.next = next; } @Override public K getKey() { return key; } @Override public V getValue() { return value; } @Override public V setValue(V value) { V oldValue = this.value; this.value = value; return oldValue; } @Override public int hashCode() { // ^ 异或运算使结果更加散列，相同为0 return (key == null ? 0 :key.hashCode()) ^ (value == null ? 0 : value.hashCode()); } } } 第一次写博客，注释也很多了，兄弟们自己将就看吧。","tags":[{"name":"数据结构","slug":"数据结构","permalink":"//louisshark.github.io/tags/数据结构/"},{"name":"java","slug":"java","permalink":"//louisshark.github.io/tags/java/"}]},{"title":"Hello World","date":"2017-04-19T09:58:12.666Z","path":"2017/04/19/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]