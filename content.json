[{"title":"搭建nginx","date":"2017-10-11T07:13:33.000Z","path":"2017/10/11/搭建ngnix/","text":"最近萌生搭建一个流媒体服务器的想法，因为自己在写一些音视频的东西，所以就想搞一个玩一玩。本篇在ubuntu16.04下成功。 第一部分：准备工作先在/root/下新建一个目录存放这些文件。 mkdir nginxcd nginx 然后在执行下面三条命令。 下载Nginxwget http://nginx.org/download/nginx-1.12.1.tar.gz 下载OpenSSL(因为Nginx依赖于OpenSSL)wget https://github.com/openssl/openssl/archive/OpenSSL_1_1_0f.tar.gz 下载Rtmpwget https://github.com/arut/nginx-rtmp-module/archive/v1.2.0.tar.gz 第二部分 编译 cd openssl-OpenSSL_1_1_0f/ mkdir bin ./config –prefix=`pwd`/bin 上面这条执行完之后会出现Makefile文件，接下来正式编译 make install 然后回到Nginx目录下 cd nginx-1.12.1/ cd auto/lib/openssl/ 然后修改conf文件 vim conf 123456789101112131415161718192021222324252627282930 if [ $ngx_found = no ]; then # MacPorts ngx_feature=\"OpenSSL library in /opt/local/\" ngx_feature_path=\"/opt/local/include\" if [ $NGX_RPATH = YES ]; then ngx_feature_libs=\"-R/opt/local/lib -L/opt/local/lib -lssl -lcrypto $NGX_LIBDL\" else ngx_feature_libs=\"-L/opt/local/lib -lssl -lcrypto $NGX_LIBDL\" fi . auto/feature fiif [ $ngx_found = no ]; then # 自己添加的一个判断 ngx_feature=\"OpenSSL library in /root/nginx/openssl-OpenSSL_1_1_0f/bin/\" ngx_feature_path=\"/root/nginx/openssl-OpenSSL_1_1_0f/bin/include\" if [ $NGX_RPATH = YES ]; then ngx_feature_libs=\"-R/root/nginx/openssl-OpenSSL_1_1_0f/bin/lib -L/root/nginx/openssl-OpenSSL_1_1_0f/bin/lib -lssl -lcrypto $NGX_LIBDL\" else ngx_feature_libs=\"-L/root/nginx/openssl-OpenSSL_1_1_0f/bin/lib -lssl -lcrypto $NGX_LIBDL\" fi . auto/feature fi 回到nginx目录下，开始编译nginx。 cd /root/nginx/nginx-1.12.1/ ./configure –prefix=`pwd`/bin –add-module=/root/nginx/nginx-rtmp-module-1.2.0 make install 之后会多一个bin目录就代表成功了，来到这个目录执行 ./nginx 如果碰到错误 error while loading shared libraries:libssl.so.1.1: cannot open shared object file: No such file or directory 可以 vim /etc/ld.so.conf 在其中加入 /root/nginx/openssl-OpenSSL_1_1_0f/bin/lib 然后执行 Ldconfig保存设置，在去配置一下服务器的入端口 1935 8080. 然后关闭nginx服务器，将nginx-rtmp-module/test/下的nginx.conf 复制到 nginx/bin/conf下面 修改一下 将路径都改为自己的rtmp-module的路径在重启就OK了。","tags":[{"name":"流媒体服务器 ubuntu","slug":"流媒体服务器-ubuntu","permalink":"https://github.com/LouisShark/tags/流媒体服务器-ubuntu/"}]},{"title":"C++编程风格笔记","date":"2017-09-11T06:19:25.000Z","path":"2017/09/11/C++编程风格笔记/","text":"C++编程风格笔记 定义函数时，参数顺序为：输入参数在前，输出参数在后。 C/C++函数参数分为输入参数和输出参数两种，有时输入参数也会输出（值被修改时），输入参数一般传值或常数引用，输出参数或输入/输出常数为非常数指针(non-const pointers)。对参数排序时，将所有输入参数置于输出参数之前。不要仅仅因为是新添加的参数，就将其置于最后，而应该依然置于输出参数之前。 包含文件的名称及次序 将包含次序标准化可增强可读性丶避免隐藏依赖(hidden dependencies， 隐藏依赖主要指包含的文件中编译时)，次序如下：C库丶C++库丶其他库的.h丶项目内的.h。 项目内头文件应按照项目源代码目录树结构排序，并且避免使用UNIX文件路径。//.(当前路径) ..（父路径）。//例如，google-awesome-project/src/base/logging.h应像这样被包含： 1#include \"base/logging.h\" dir/foo.cc的主要作用是执行或测试dir2/foo2.h的功能，foo.cc中包含头文件的次序如下： 12345dir2/foo2.hC系统文件C++系统文件其他库头文件本项目内头文件 这种排序方式可有效减少隐藏依赖，我们希望每一个头文件都独立编译。最简单的实现方式是将其作为第一个.h文件包含在对应的.cc中。 dir/foo.cc和 dir2/foo2.h通常位于相同目录下（像base/basictypes_unittest.cc和base/basictypes.h），但也可在不同的目录下。 相同目录下头文件按字母排序是不错的选择。 举例来说，“google-awesome-project/src/foo/internal/fooserver.cc”的包含次序如下： 12345678#include &quot;foo/public/fooserver.h&quot; //优先位置#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;hash_map&gt;#include &lt;vector&gt;#include &quot;base/basictypes.h&quot;#include &quot;base/commandlineflags.h&quot;#include &quot;foo/public/bar.h&quot; 总结以上： 避免多重包含是学编程时最基本的要求。 前置声明是为了降低编译依赖，防止修改一个头文件引发多米诺效应。 内联函数的合理使用可提高代码执行效率。 -inl.h 可提高代码可读性。 标准化函数参数顺序可以提高可读性和以易维护性(对函数参数的堆栈空间有轻微影响) 包含文件的名称使用.和..虽然方便却易混乱，使用比较完整的项目路径看上去很清晰丶很条理，包含文件的次序除了美观之外，最重要的是可以减少隐藏依赖，使每个头文件在“最需要编译”的地方编译(对应源文件处)，有人提出库文件放在最后，这样出错先是项目内的文件，头文件都放在对应源文件的最前面，这一点足以保证内部错误的即时发现了。 局部变量 将函数尽可能置于最小作用域内，在声明变量时将其初始化。 C++允许在函数的任何位置声明变量。提倡在尽可能小的作用域内声明变量，离第一次使用越近越好。这使得代码易于阅读，易于定位变量的声明位置丶变量类型和初始值。特别是，应使用初始化代替声明+赋值的方式。 123int i;i = f(); //坏 ---- 初始化和声明分离int j = g()； //好------初始化时声明 注意：gcc可正确执行for(int i =0; i &lt; 10 ;++i)(i的作用域仅限for循环),因此其他for循环可重用i。if和 while 等语句中，作用域声明同样是正确的。 1while(const char* p= strchr(str, &apos;/&apos;)) str = p +1; 注意：如果变量是一个对象，每次进入作用域都要调用其构造函数，每次退出都要调用其析构函数。 //低效的实现 1234for(int i = 0; i &lt; 1000000; ++i) &#123; Foo f; f.DoSomething();&#125; 类似变量要放到循环作用域外面声明要高效的多： 1234Foo f;for (int i = 0; i &lt; 1000000; ++i) &#123; f.DoSomething();&#125; 全局变量 class类型的全局变量是被禁止的，内建类型的全局变量是允许的，当然多线程代码中非常数全局变量也是被禁止的。永远不要使用函数返回值初始化全局变量。如果一定要使用class类型的全局变量，请使用单例模式(singleton pattern)。 对于全局的字符串常量，使用C风格的字符串，而不要使用STL的字符串： 1const char kFrogSays[] = &quot;ribbet&quot;; 虽然允许在全局作用域使用全局变量，但请三思。大多数全局变量应该是类的静态数据成员，或者当其只在.cc文件中使用时，将其定义到不具名命名空间中，或者使用静态关联以限制变量的作用域。 记住，静态成员变量视作全局变量，所以也不能是class类型！！ 总结： .cc文件中的不具名空间可避免命名冲突丶限定作用域，避免直接使用using提示符污染命名空间。 嵌套类符合局部使用原则，只是不能在其他头文件中前置声明，尽量不要public。 尽量不用全局函数和全局变量，考虑作用域和命名空间限制，尽量单独形成编译单元。 多线程中的全局变量(含静态成员变量)不要使用class类型(含STL容器)，避免不明确行为导致的bugs。 作用域的使用，除了考虑名称污染可读性之外，主要是为降低耦合度，提高编译丶执行效率。 类 介绍类该做声明，不该做什么。 explicit: 明确的 implicit: 隐含的 trivial: 没有意义的 non-trivial: 有意义的 #1.构造函数的职责 构造函数中只进行那些没有实际意义的初始化(trivial，简单初始化对于程序执行没有实际的逻辑意义，因为成员变量的“有意义”的值大多不在构造函数中确定)，可能的话，使用Init()方法集中初始化为有意义的数据(non-trivial). 定义：在构造函数中执行初始化操作。 优点：排版方便，无需担心类是否初始化。 缺点：在构造函数中执行操作引起的问题有： 构造函数不易报告错误，不能使用异常 操作失败会造成对象初始化失败，引起不确定状态 构造函数内调用虚函数，调用不会派发到子类实现中，即时当前没有子类化实现，将来仍是隐患 如果有人创建该类型的全局变量，构造函数将在main()之前被调用，有可能破坏构造函数中暗含的假设条件 结论：如果对象需要有意义的(non-trivial)初始化，考虑使用另外的Init()方法并增加一个成员标志用于指示对象是否初始化成功。 ###2.默认构造函数 如果一个类定义了若干成员变量又没有其他构造函数，需要定义一个默认构造函数，否则编译器将自动生产默认构造函数。 定义：新建一个没有参数的对象时，默认构造函数被调用，当调用new[]（为数组）时，默认构造函数总是被调用。 优点：默认将结构体初始化为“不可能的值。”，使调试更加容易。 缺点：对代码编写者来说是多余的工作。 结论： 如果类中定义了成员变量，没有提供其他构造函数，你需要定义一个默认构造函数(无参数)。默认构造函数更适合初始化对象，使对象内部状态(internal state)一致，有效。 提供默认构造函数的原因是：如果倪没有提供其他构造函数，又没有定义默认构造函数。编译器会自动生成一个，但编译器生成的构造函数不会对对象进行初始化。 如果你定义的类继承现有类，而你又没有增加新的成员变量，则不需要为新类定义默认构造函数。 ###3.明确的构造函数(Explicit Constructors) 对单参数构造函数使用C++关键字explicit。 定义：只有一个参数的构造函数可被用于转换(只要指隐式转换)。例如，定义了Foo::Foo(string name),当向需要传入一个Foo对象的函数传入一个字符串时，构造函数Foo::Foo(string name)被调用并将该字符串转换为一个Foo临时对象传给调用函数。看上去方便，但是如果你并不希望通过转换生成一个新对象的话，麻烦也随着而来，为避免构造函数被调用造成隐式转换，可以将其声明为explicit。 优点：避免不合时宜的转换 缺点：无 结论 所有单参数构造函数必须是明确的(explicit)。在类定义中，将关键字explicit加到单参数构造函数前： explicit Foo(string name) 例外：在少数情况下，拷贝构造函数可以不声明为explicit；特意作为其他类的透明包装器的类。 4.拷贝构造函数仅在代码中需要拷贝一个类对象的时候使用拷贝构造函数；不需要拷贝时应使用DISALLOW_COPY_AND_ASSIGN。 定义：通过拷贝新建对象时可使用拷贝构造函数(特别是对象的传值时). 优点：拷贝构造函数使得拷贝对象更加容易，STL容器要求所有内容可拷贝丶可赋值。 缺点：C++中对象的隐式拷贝是导致很多性能问题和bugs的根源。拷贝构造函数降低了代码可读性，相比于按引用传递，跟踪按值传递的对象更加困难，对象修改的地方变得难以琢磨。 结论： 大量的类并不需要可拷贝，也不需要一个拷贝构造函数或赋值操作。但不幸的是，你不主动声明他们，编译器会为你自动生成，而且是public。 可以考虑在类的private中添加空的(dummy)拷贝构造函数和赋值操作，只有声明，没有定义。由于这些空程序声明为private，当其他代码视图使用他们时，编译器将报错，为了方便，可以使用宏定义DISALLOW_COPY_AND_ASSIGN。 123456789101112//禁止使用拷贝构造函数和赋值操作的宏//应在类的private:中使用#define DISALLOW_COPY_AND_ASSIGN(TypeName) \\ TypeName(const TypeName&amp;); \\ void operator = (const TypeName&amp;)class Foo &#123; public: Foo(int f); ~Foo(); private: DISALLOW_COPY_AND_ASSIGN(Foo);&#125;; 如上所述，绝大多数情况应使用DISALLOW_COPY_AND_ASSIGN,如果类确实需要拷贝，应在该类的头文件中说明原由，并适当定义拷贝构造函数和赋值操作，注意在operator中检测自赋值(self-assignment)情况。 在将类作为STL容器值的时候，你可能有使类可拷贝的冲动。类似情况下，真正该做的是使用指针指向STL容器中的对象，可以考虑使用 std::tr1::shared_ptr. 5.结构体和类（struct vs Classes）仅当只有数据时使用struct，其他一律使用class。 在C++中，关键字struct和class几乎含义等同，我们为其认为添加语义，以便为定义的数据类型合理选择使用哪个关键字。 struct被用在仅包含数据的消极对象(passive objetcts)上，可能包括有关联的常量，但没有存取数据成员之外的函数功能，而存取功能通过直接访问实现而无需方法调用，这提到的方法是只用于处理数据成员的，如构造函数丶析构函数丶Initialize()丶Reset()丶Validate(). 如果需要更多的函数功能，class更适合，如果不确定，直接使用class。 如果与STL结合，对于仿函数(functors)和特性(traits)可以不用class而是使用struct。 6.继承(inheritance)使用组合(composition)通常比继承更适宜，如果使用继承的话，只是用公共继承。 定义：当子类继承基类时，子类包含了父基类所有数据及操作的定义。C++中，继承主要用于两个场合：1.实现继承，子类继承父类的实现代码。2.接口继承，子类仅继承父类的方法名称。 优点：实现继承通过原封不动的重用基类代码减少了代码量。由于继承是编译时声明，编码者和编译器都可以理解相应操作并发现错误。接口继承可用于程序上增强类的特定API的功能，在类没有定义API的必要实现时，编译器同样可以甄错。 缺点：对于实现继承，由于实现子类的代码在父类和子类间延展，要理解其实现变得更加困难。子类不能重写父类的非虚函数，当然也就不能修改其实现。基类也可能定义一些数据成员，还要区分基类的物理轮廓(physical layout)。 结论： 所有继承必须是public的，如果想私有继承的话，应该采取包含基类实例作为成员的方式作为替代。 不要过多实现继承，组合通常更合适一些。努力做到只在“是一个”的情况下使用继承；如果Bar的确是一种Foo，才令Bar是Foo的子类。 必要的话，析构函数必须是virtual，必要是指，如果该类具有虚函数，其析构函数应该为虚函数。 至于子类没有额外数据成员，父类也没有任何数据成员的特殊情况下，析构函数的调用是否必要是语义争论，从编程设计规范的角度看，在含有虚函数的父类中，定义虚函数绝对必要。 限定仅在子类访问的成员函数为protected，需要注意数据成员应该始终为私有。 当重定义派生的虚函数时，在派生类中明确声明其为virtual。根本原因：如果遗漏virtual，阅读者需要检索其所有祖先以确定该函数是否为虚函数。 7.多重继承真正需要多重实现继承的时候非常少，只有当最多一个基类中含有实现，其他基类都是以Interface为后缀的纯接口类时才会使用多继承。 定义：多重继承允许子类拥有多个基类，要将作为纯接口的基类和具有实现的基类区别开来。 优点：相比于单继承，多重实现继承可令你重用更多代码 缺点：真正需要用到多重实现继承的时候非常少，多重实现继承看上去是不错的解决方案，通常可以找到更加明确丶清晰丶不同的解决方案 结论： 只有当所有超类除第一个外都是纯接口时才能使用多重继承。为确保它们是纯接口，这些类必须以Interface为后缀。 8.接口接口是指满足指定特定条件的类，这些类以interface为后缀(非必须)。 当一个类满足以下条件时，称为纯接口： 只有纯虚函数(“=0”)和静态函数(下文提到的析构函数除外)。 没有非静态数据成员。 没有定义任何构造函数。如果有也不含参数，并且为protected。 如果是子类，也只能继承满足以上条件并以interface为后缀的类。 接口类不能被直接实例化，因为它声明了纯虚函数。为确保接口类的所有实现可被正确销毁，必须为之声明虚析构函数(作为第一条的例外，析构函数不可能为纯虚函数)。 优点：以interface为后缀可令他人知道不能为该接口类增加实现函数或非静态数据成员，这一点对多重继承尤其重要 缺点：interface后缀增加了类名长度，为阅读和理解带来不变，接口特性作为实现细节不应暴露给客户。 结论： 只有在满足上述需要时，类才以interface结尾，但反过来满足上述需要的类未必一定以interface结尾。 9.操作符重载除少数特定环境外，不要重载操作符。 定义：一个类可以定义诸如 + 丶/等操作符，使其可以像内建类型一样直接使用。 优点：是代码看上去更加直观，就像内建类型(如int)那样，重载操作符使那些equal丶add等暗淡无关的函数名好玩多了。为了使一些模板函数正确工作，可能需要定义操作符。 缺点：虽然操作符重载令代码更加直观，但也有一些不足。 混淆直觉，让你误以为一些耗时操作像内建操作那样轻巧 查找重载操作符的调用处更加困难，查找equal显然比同等调用==容易的多。 有的操作符可以对指针进行操作，容易导致bugs丶Foo+4 做的是一件事，而&amp;Foo+4 可能做的是完全不同的另一件事，对于二者，编译器都不会报错，使其很难调试。 重载还有令你吃惊的副作用，比如重载操作符&amp;的类不能被前置声明。 结论： 一般不要重载操作符，尤其是赋值操作(operator==)比较阴险，应避免重载，需要的话可以定义类似equal丶copyFrom等函数。 然而，极少数情况下需要重载操作符以便与模板或“标准”C++类衔接(operator&lt;&lt;(ostream&amp;,const T&amp;)),如果被证明是正当的尚可接受，但你要尽可能避免这样做尤其是不要仅仅为了在STL容器中作为key使用就重载operator==或operator&lt;，取而代之，你应该在声明容器的时候，创建相等判断和大小比较的仿函数类型。 有些STL算法确实需要重载operator==时可以这么做，不要忘了提供文档说明原因。 参考拷贝构造函数和函数重载。 10.存取控制将数据成员私有化，并提供相关存取函数，如定义变量foo_及取值函数foo()丶赋值函数set_foo(). 存取函数的定义一般内联在头文件中。 参考继承和函数命名。 11.声明次序在类中使用特定的声明次序：public:在private:之前，成员函数在数据成员(变量)前。 定义次序如下：public:丶protected:丶private:. 每一块中，声明次序一般如下： typedefs和enums； 常量 构造函数 析构函数 成员函数，含静态函数 数据成员，含静态数据成员 宏DISALLOW_COPY_AND_ASSIGN置于private:块之后，作为类的最后部分。参考拷贝构造函数。 .cc文件中函数的定义应尽可能和声明次序一致。 不要将大型函数内联到类的定义中，只有那些没有特定意义的或者性能要求高的，并且是比较短小的函数才能被定义为内联函数。 关于类的结论 不在构造函数内做太多关于逻辑的初始化 编译器提供的默认构造函数不会对变量进行初始化，如果定义了其他构造函数，编译器不再提供，需要编码者自行提供默认构造函数 为避免隐式转换，须将单参数构造函数声明为explicit 为避免拷贝构造函数丶赋值操作的滥用和编译器自动生成，可目前声明其为private且无需实现 仅在作为数据集合时使用struct 组合 &gt; 实现继承 &gt; 接口继承 &gt;私有继承，子类重载的虚函数也要声明virtual关键字，虽然编译器允许不这样做 避免使用多重继承，使用时，除一个基类含有实现外，其他基类均为纯接口 接口类类名以interface为后缀，除提供带实现的虚析构函数丶静态成员函数外，其他均为纯虚函数，不定义非静态数据成员，不提供构造函数，提供的话，声明为protected 为降低复杂性，尽量不重载操作符，模板丶标准类中使用时提供文档说明 存取函数一般内联在头文件中 声明次序：public-&gt;protected-&gt;private 函数体尽量短小丶紧凑，功能单一","tags":[{"name":"C++","slug":"C","permalink":"https://github.com/LouisShark/tags/C/"},{"name":"笔记","slug":"笔记","permalink":"https://github.com/LouisShark/tags/笔记/"}]},{"title":"Mrak message parts that should not be translated","date":"2017-07-05T06:41:32.000Z","path":"2017/07/05/Mrak-message-parts-that-should-not-be-translated/","text":"好久没写博客了，最佳一直在看官网的training啊，突然看到一个奇怪的东西，没错就是标题的那个东西，官网是这样子介绍的： Often strings contain contain text that should not be translated into other languages. Common examples might be a piece of code, a placeholder for a value, a special symbol, or a name. As you prepare your strings for translation, look for and mark text that should remain as-is, without translation, so that the translator doesn’t change it. 这几句话大家应该都能看得懂，大概意思就是不让字符串中的代码，占位符，特殊标识或者名字什么的被翻译，而你就要控制他们不被改变。我其实看完有点无语，意思很明显，但是我看不懂啊，于是我把它的示例的string资源打印了一下看看是什么效果(我也是很无聊的)： 123&lt;string name=\"countdown\"&gt; &lt;xliff:g id=\"time\" example=\"5 days&gt;%2$8s&lt;/xliff:g&gt; until holiday&lt;/string&gt; 就是上面这段资源，粘贴到string.xml里面，然后在java中代码动态改变值: 1tv.text(resources.getString(R.string.countdown, \"shark\", \"louis\")) 对了上面这是Kotlin的写法，最近也是在学习这一门大热的语言，这不是重点啊，让我们看看打印的结果： 1louis until holiday 看到没有，我也是试了几下才知道的，%2$8s你们猜到什么意思了吧，没错，2表示的是getString后面的可变参数的位置，意思就是从id后面数起的第二个取代这个占位符，而$8s则表示前面8个空格，并且是字符串 属性id可以随便命名属性example表示举例说明，可以省略%n$ms：代表输出的是字符串，n代表是第几个参数，设置m的值可以在输出之前放置空格%n$md：代表输出的是整数，n代表是第几个参数，设置m的值可以在输出之前放置空格，也可以设为0m,在输出之前放置m个0%n$mf：代表输出的是浮点数，n代表是第几个参数，设置m的值可以控制小数位数，如m=2.2时，输出格式为00.00 贴出官方说法。 注意在String.xml中加命名空间&lt;resources xmlns:xliff=&quot;urn:oasis:names:tc:xliff:document:1.2&quot;&gt; 以上。。 在这其中我发现了一个方法getQuantityString 这个和上面那个很像啊有木有，于是我查了一下资料发现这是对不同语言的单复数的定义不同时的写法，对某些语言的特殊写法吧，这个得和你们的翻译人员问问了。 值 描述 zero 语言需要对数字0进行特殊处理。（比如阿拉伯语） one 语言需要对类似1的数字进行特殊处理。（比如英语和其它大多数语言里的1；在俄语里，任何以1结尾但不以11结尾的数也属于此类型。） two 语言需要对类似2的数字进行特殊处理。（比如威尔士语） few 语言需要对较小数字进行特殊处理（比如捷克语里的2、3、4；或者波兰语里以2、3、4结尾但不是12、13、14的数。） many 语言需要对较大数字进行特殊处理（比如马耳他语里以11-99结尾的数） other 语言不需要对数字进行特殊处理。 看到这个表格我在试一试呗。 1234&lt;plurals name=\"subtitle_plural\"&gt; &lt;item quantity=\"one\"&gt;one crime&lt;/item&gt; &lt;item quantity=\"other\"&gt;%1$s crimes&lt;/item&gt;&lt;/plurals&gt; 在activity中这样写，对比一下效果 12tv.append(resources.getQuantityString(R.plurals.subtitle_plural, 3, 3).toString() + \"\\n\")tv.append(resources.getQuantityString(R.plurals.subtitle_plural, 1, 1)) 结果： 123 crimesone crime 看到这里你也应该明白了，这次的博客内容就这些了，谢谢大家。","tags":[{"name":"官网Guide","slug":"官网Guide","permalink":"https://github.com/LouisShark/tags/官网Guide/"},{"name":"本地化资源","slug":"本地化资源","permalink":"https://github.com/LouisShark/tags/本地化资源/"}]},{"title":"AppCompatActivity的作用分析","date":"2017-06-23T09:29:00.000Z","path":"2017/06/23/AppCompatActivity的作用分析/","text":"AppCompatActivity的作用分析 对于v7包下的AppCompatActivity，我是比较晚入的android(并不知道是不是坑)，所以一开始就用的as创建项目就很奇怪为什么我的activity自动继承了AppCompatActivity，不是应该继承Activity吗？Ecm？我仿佛感觉受到了欺骗，于是就对其进行了研究(就是看源码拉)。(因为当时是边看边解析边写的，所以思路可能有点乱，自己再看一遍源码更好，也是学习的一部分) 一开始我就发现了v4 v7 v13等等的support库，然后发现这些库是用来解决兼容问题的，数字分别对应了android的API版本，即分别适配android版本4，7，13以上的app。看完之后发现google程序员为了适配也是良苦用心啊。 从AppCompatActivity源码的onCreate看到这个类初始化的第一步就调用了getDelegate获得了一个代理，并且你会发现下面所有的生命周期的方法都交由这个代理类来实现了，那么这个东西是什么呢？其实就是AppCompatDelegate这个抽象类。 1234567891011121314151617181920212223242526272829 @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; final AppCompatDelegate delegate = getDelegate(); delegate.installViewFactory(); delegate.onCreate(savedInstanceState); if (delegate.applyDayNight() &amp;&amp; mThemeId != 0) &#123; // If DayNight has been applied, we need to re-apply the theme for // the changes to take effect. On API 23+, we should bypass // setTheme(), which will no-op if the theme ID is identical to the // current theme ID. if (Build.VERSION.SDK_INT &gt;= 23) &#123; onApplyThemeResource(getTheme(), mThemeId, false); &#125; else &#123; setTheme(mThemeId); &#125; &#125; super.onCreate(savedInstanceState); &#125;/** * @return The &#123;@link AppCompatDelegate&#125; being used by this Activity. */ @NonNull public AppCompatDelegate getDelegate() &#123; if (mDelegate == null) &#123; mDelegate = AppCompatDelegate.create(this, this); &#125; return mDelegate; &#125; 那么AppCompatDelegate这个类到底做了什么呢？点进去看这个create方法 123public static AppCompatDelegate create(Activity activity, AppCompatCallback callback) &#123; return create(activity, activity.getWindow(), callback);&#125; 然后调用： 123456789101112131415private static AppCompatDelegate create(Context context, Window window, AppCompatCallback callback) &#123; final int sdk = Build.VERSION.SDK_INT; if (BuildCompat.isAtLeastN()) &#123; return new AppCompatDelegateImplN(context, window, callback); &#125; else if (sdk &gt;= 23) &#123; return new AppCompatDelegateImplV23(context, window, callback); &#125; else if (sdk &gt;= 14) &#123; return new AppCompatDelegateImplV14(context, window, callback); &#125; else if (sdk &gt;= 11) &#123; return new AppCompatDelegateImplV11(context, window, callback); &#125; else &#123; return new AppCompatDelegateImplV9(context, window, callback); &#125;&#125; 是不是感觉这些名字有点熟悉呢。 这个方法返回了一些根据版本号的实现类。 下面我将给出这个抽象类的类之间的继承关系： 在as 中使用ctrl + H的快捷键可以很快的看到类之间的继承图。 发现他们之间相互继承，于是开始看V9的源码，找到了一个可疑的方法： 12345678910111213141516171819202122232425262728293031323334/** 这个方法会(invoke) &#123;当我们使用自己的layoutInflater的factory的时候&#125; */ @Override public View createView(View parent, final String name, @NonNull Context context, @NonNull AttributeSet attrs) &#123; final boolean isPre21 = Build.VERSION.SDK_INT &lt; 21; if (mAppCompatViewInflater == null) &#123; mAppCompatViewInflater = new AppCompatViewInflater(); &#125; // We only want the View to inherit its context if we're running pre-v21 final boolean inheritContext = isPre21 &amp;&amp; shouldInheritContext((ViewParent) parent); return mAppCompatViewInflater.createView(parent, name, context, attrs, inheritContext, isPre21, /* Only read android:theme pre-L (L+ handles this anyway) */ true, /* Read read app:theme as a fallback at all times for legacy reasons */ VectorEnabledTintResources.shouldBeUsed() /* Only tint wrap the context if enabled */ ); &#125; @Override public void installViewFactory() &#123; LayoutInflater layoutInflater = LayoutInflater.from(mContext); if (layoutInflater.getFactory() == null) &#123; LayoutInflaterCompat.setFactory(layoutInflater, this); &#125; else &#123; if (!(LayoutInflaterCompat.getFactory(layoutInflater) instanceof AppCompatDelegateImplV9)) &#123; Log.i(TAG, \"The Activity's LayoutInflater already has a Factory installed\" + \" so we can not install AppCompat's\"); &#125; &#125; &#125; 突然想起来一句话，兼容问题其实就是着色问题，AppCompatDelegate 的工作就是涂色。发现这个方法在AppCompatDelegate里面定义的，别问我怎么找到的，你在V9这个类看到1000多行代码的时候找到了，然后我跑回去看AppCompatDelegate这个类里面的方法。 12345678910111213141516171819202122232425262728293031/** * Installs AppCompat's &#123;@link android.view.LayoutInflater&#125; Factory so that it can replace * the framework widgets with compatible tinted versions. This should be called before * &#123;@code super.onCreate()&#125; as so: * &lt;pre class=\"prettyprint\"&gt; * protected void onCreate(Bundle savedInstanceState) &#123; * getDelegate().installViewFactory(); * getDelegate().onCreate(savedInstanceState); * super.onCreate(savedInstanceState); * * // ... * &#125; * &lt;/pre&gt; * If you are using your own &#123;@link android.view.LayoutInflater.Factory Factory&#125; or * &#123;@link android.view.LayoutInflater.Factory2 Factory2&#125; then you can omit this call, and instead call * &#123;@link #createView(android.view.View, String, android.content.Context, android.util.AttributeSet)&#125; * from your factory to return any compatible widgets. */ public abstract void installViewFactory(); /** * This should be called from a * &#123;@link android.view.LayoutInflater.Factory2 LayoutInflater.Factory2&#125; in order * to return tint-aware widgets. * &lt;p&gt; * This is only needed if you are using your own * &#123;@link android.view.LayoutInflater LayoutInflater&#125; factory, and have therefore not * installed the default factory via &#123;@link #installViewFactory()&#125;. */ public abstract View createView(@Nullable View parent, String name, @NonNull Context context, @NonNull AttributeSet attrs); 看到上面的注释我突然顿悟了，找了半天的在哪里设置的layoutInflater的factory，原来是这样子，于是又去AppCompatActivity瞅了一眼： 12345protected void onCreate(@Nullable Bundle savedInstanceState) &#123; final AppCompatDelegate delegate = getDelegate(); delegate.installViewFactory(); delegate.onCreate(savedInstanceState); &#125; 发现onCreate方法里果然有这句话，installViewFactory()；这个方法就是给The Activity’s LayoutInflater设置一个自己的factory，于是就会调用createView这个方法 注意createView里面的这句话： 12345return mAppCompatViewInflater.createView(parent, name, context, attrs, inheritContext, isPre21, /* Only read android:theme pre-L (L+ handles this anyway) */ true, /* Read read app:theme as a fallback at all times for legacy reasons */ VectorEnabledTintResources.shouldBeUsed() /* Only tint wrap the context if enabled */ ); 于是跑到AppCompatViewInflater的createView方法看，终于找到了： 123456789101112131415161718192021222324252627282930313233343536373839404142// We need to 'inject' our tint aware Views in place of the standard framework versions switch (name) &#123; case \"TextView\": view = new AppCompatTextView(context, attrs); break; case \"ImageView\": view = new AppCompatImageView(context, attrs); break; case \"Button\": view = new AppCompatButton(context, attrs); break; case \"EditText\": view = new AppCompatEditText(context, attrs); break; case \"Spinner\": view = new AppCompatSpinner(context, attrs); break; case \"ImageButton\": view = new AppCompatImageButton(context, attrs); break; case \"CheckBox\": view = new AppCompatCheckBox(context, attrs); break; case \"RadioButton\": view = new AppCompatRadioButton(context, attrs); break; case \"CheckedTextView\": view = new AppCompatCheckedTextView(context, attrs); break; case \"AutoCompleteTextView\": view = new AppCompatAutoCompleteTextView(context, attrs); break; case \"MultiAutoCompleteTextView\": view = new AppCompatMultiAutoCompleteTextView(context, attrs); break; case \"RatingBar\": view = new AppCompatRatingBar(context, attrs); break; case \"SeekBar\": view = new AppCompatSeekBar(context, attrs); break; &#125; 原来在activity的oncreate一开始创建的时候，系统就自动帮我们把这些色调给我们换掉了所以你写在XML的控件，都会被换成AppCompat开头的兼容性的控件，当然前提是你要继承AppCompatActivity，这就是系统为我们所做的适配了，请注意，AppCompatViewInflater也给我们提供了一个热换肤的思路，下次有时间再说吧。 总结起来，这个兼容其实就是偷梁换柱，而且看源码一定不能被细枝末节影响，像我一样，如果我能做点笔记，而不是草率的开始，应该过程会更加的轻松。","tags":[{"name":"源码分析","slug":"源码分析","permalink":"https://github.com/LouisShark/tags/源码分析/"},{"name":"android","slug":"android","permalink":"https://github.com/LouisShark/tags/android/"}]},{"title":"滑动冲突的解决方式","date":"2017-06-14T03:04:10.000Z","path":"2017/06/14/滑动冲突的解决方式/","text":"外部拦截法 即指点击事件都先经过父容器的拦截处理，如果父容器需要此事件就拦截，如果不需要此事件就不拦截，这样就可以解决滑动冲突的问题，这种方法比较符合点击事件的分发机制。外部拦截法要重写父容器的onInterceptTouchEvent方法，并在内部做相应的拦截。伪代码如下： 1234567891011121314151617181920212223242526@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) &#123; boolean intercepted = false; int x = (int) ev.getX(); int y = (int) ev.getY(); switch (ev.getAction()) &#123; case MotionEvent.ACTION_DOWN: intercepted = false; break; case MotionEvent.ACTION_MOVE: if (父容器需要当前点击事件)&#123; intercepted = true; &#125; else &#123; intercepted = false; &#125; break; case MotionEvent.ACTION_UP: intercepted = false; break; default: break; &#125; mLastXIntercept = x; mLastYIntercept = y; return intercepted;&#125; 上述代码是外部拦截法的典型逻辑，针对不同的滑动冲突，只需要修改父容器需要当前点击事件这个条件即可，其他均不需并且也不能修改。 对上述代码进行讲解： ​ ACTION_DOWN事件返回false，因为父容器拦截了down事件，后续的action_move和action_up事件都会直接 交由父容器处理，事件无法传递给子元素.​ ACTION_MOVE事件，可以根据需要来决定是否拦截，如果父容器拦截就返回true，不拦截就返回false。​ ACTION_UP事件，必须返回false，因为up事件本身并没有多大的意义。 考虑一种情况，假设事件交由子元素处理，如果父容器在ACTION_UP时返回了true，就会导致子元素无法接收到ACTION_UP事件，这个时候子元素中的onclick事件就无法触发，但是父容器比较特殊，一旦它开始拦截任何一个事件，那么后续的事件都会交由它来处理，而ACTION_UP作为最后一个事件也必定可以传递给父容器，即使父容器的onInterceptTouchEvent方法在ACTION_UP时返回了false. 内部拦截法 内部拦截法是指父容器不拦截任何事件，所有的事件都传递给子元素，如果子元素需要此事件就直接消耗掉，否则就交由父容器进行处理，这种方法和android中的事件分发机制就不一样，需要配合requestDisallowInterceptTouchEvent方法才能正常工作，使用起来比外部拦截法稍显复杂。伪代码如下： 1234567891011121314151617181920212223242526@Overridepublic boolean dispatchTouchEvent(MotionEvent event) &#123; int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: parent.requestDisallowInterceptTouchEvent(true); break; case MotionEvent.ACTION_MOVE: int deltaX = x - mLastX; int deltaY = y - mLastY; if (父容器需要此类点击事件) &#123; parent.requestDisallowInterceptTouchEvent(false); &#125; break; case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: break; default: break; &#125; mLastX = x; mLastY = y; return super.dispatchTouchEvent(event);&#125; 上述代码是内部拦截法的典型代码，当面对不同的滑动策略时只需要修改里面1的条件即可，其他不需要做改动也不需要做改动。除了子元素需要做处理以外，父元素也要默认拦截除了ACTION_DOWN以外的其他事件，这样当子元素调用parent.requestDisallowInterceptTouchEvent(false)方法时，父元素才能继续拦截所需的事件。 为什么父容器不能拦截ACTION_DOWN事件呢，因为这个事件不受FLAG_DISALLOW_INTERCEPT这个标记位的控制，所以一旦父容器拦截ACTION_DOWN事件了，那么所有的事件都无法传递到子元素去，这样内部拦截法就无法起作用了。 父元素的修改如下： 12345678910@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) &#123; int action = ev.getAction(); if (action == MotionEvent.ACTION_DOWN) &#123; return false; &#125; else &#123; return true; &#125;&#125; ​","tags":[{"name":"自定义view","slug":"自定义view","permalink":"https://github.com/LouisShark/tags/自定义view/"},{"name":"滑动冲突","slug":"滑动冲突","permalink":"https://github.com/LouisShark/tags/滑动冲突/"},{"name":"事件分发","slug":"事件分发","permalink":"https://github.com/LouisShark/tags/事件分发/"}]},{"title":"使用SVG来实现复杂的自定义View","date":"2017-06-02T01:48:53.000Z","path":"2017/06/02/使用SVG来实现复杂的自定义View/","text":"最近发现可以用SVG来实习非常复杂的自定义View，可以说是非常的厉害了。只要你看到不想做的很复杂的设计图，你就让美工妹子给你来一张SVG吧，还可以趁机和她聊下天。 我们就来画一个可交互的中国台湾地图吧，首先我们来理一下做这种自定义View的步骤。 下载含有中国地图的 SVG 用此 网站 将svg资源转换成相应的 Android代码 利用Xml解析SVG的代码 封装成javaBean 最重要的得到Path 重写OnDraw方法 利用Path绘制中国地图 重写OnTouchEvent方法，记录手指触摸位置，判断这个位置是否坐落在某个省份上 对了，地图资源可以在这里 下载。开始写代码吧。 项目地址点这里可以看源码。 前两步不需要我如何说了吧，可以把转化后的android代码，放入res/raw目录下，接下来开始第三步： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private void parseXMLWithPull() &#123; InputStream inputStream = null; try &#123; inputStream = context.getResources().openRawResource(R.raw.taiwanhigh); XmlPullParserFactory factory = XmlPullParserFactory.newInstance(); factory.setNamespaceAware(true); XmlPullParser xmlPullParser = factory.newPullParser(); xmlPullParser.setInput(inputStream, \"UTF-8\"); int eventType = xmlPullParser.getEventType(); ProvinceItem item = null; while (eventType != XmlPullParser.END_DOCUMENT) &#123; String nodeName = xmlPullParser.getName(); switch (eventType) &#123; //开始解析某个节点 case XmlPullParser.START_DOCUMENT: itemList = new ArrayList&lt;&gt;(); break; case XmlPullParser.START_TAG: if (\"path\".equals(nodeName)) &#123; String pathData = xmlPullParser.getAttributeValue(\"http://schemas.android.com/apk/res/android\", \"pathData\"); Path path = PathParser.createPathFromPathData(pathData); item = new ProvinceItem(path); &#125; break; case XmlPullParser.END_TAG: if (nodeName.equalsIgnoreCase(\"path\") &amp;&amp; item != null) &#123; assert itemList != null; itemList.add(item); item = null; handler.sendEmptyMessage(PARSE_END); &#125; break; default: break; &#125; eventType = xmlPullParser.next(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (inputStream != null) &#123; try &#123; inputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; xml解析写的非常随便，如果有需要修改的请自行修改，这里主要的是将解析出来的path标签下的pathData，然后使用封装好的PathParser(这个类大家可以自己去搜索下载)来将pathData封装成path，然后将path传入ProvinceItem类生成java bean类。下面我们来看一下这个Bean类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/* 路径 */ private Path path; /* 绘制颜色 */ private int drawColor; public ProvinceItem(Path path) &#123; this.path = path; &#125; /** * 自绘 * @param canvas * @param paint * @param isSelect */ public void draw(Canvas canvas, Paint paint, boolean isSelect) &#123; if (isSelect) &#123; //绘制背景 paint.setStrokeWidth(2); paint.setColor(Color.BLACK); paint.setStyle(Paint.Style.FILL); paint.setShadowLayer(8, 0, 0, 0xffffffff); canvas.drawPath(path, paint); //绘制省份 paint.clearShadowLayer(); paint.setColor(drawColor); paint.setStyle(Paint.Style.FILL); paint.setStrokeWidth(2); canvas.drawPath(path, paint); &#125; else &#123; //没有被选择的时候绘制内容 paint.clearShadowLayer(); paint.setColor(drawColor); paint.setStyle(Paint.Style.FILL); paint.setStrokeWidth(1); canvas.drawPath(path, paint); //选择的时候绘制边界线 paint.setStyle(Paint.Style.STROKE); paint.setColor(0XFFEEEEEE); canvas.drawPath(path, paint); &#125; &#125; /* 判断是否点击了省份 */ public boolean isTouch(int x, int y) &#123; RectF rectF = new RectF(); //就是用path的四个点生成一个rectf path.computeBounds(rectF, true); Region region = new Region(); //setPath 就是用path在region里面剪切出一个区域 region.setPath(path, new Region((int) rectF.left, (int) rectF.top, (int) rectF.right, (int) rectF.bottom)); return region.contains(x, y); &#125; 这个类主要就是两个方法，draw方法和isTouch方法，下面来说这两个方法的作用： drawdraw方法主要是传递三个参数来进行自绘： canvas 画板 paint 画笔 isSelect 是否被选中 因为这个方法用来处理被点击时界面的变化，未选中和被选中的效果是不一样的。 此处可以自己来随便写。 isTouch这个方法判断这个区域是否被选中，当然也可以有其他的方法来判断是否被点击，这里提供一种思路，主要是region里面的setPath方法，我们点进去源码看一下 12345678910&gt; /**&gt; * Set the region to the area described by the path and clip.&gt; * Return true if the resulting region is non-empty. This produces a region&gt; * that is identical to the pixels that would be drawn by the path&gt; * (with no antialiasing).&gt; */&gt; public boolean setPath(Path path, Region clip) &#123;&gt; return nativeSetPath(mNativeRegion, path.readOnlyNI(), clip.mNativeRegion);&gt; &#125;&gt; &gt; 大概的意思就是用这个path在region裁剪出一个region，这个区域就是省份的区域，是不规则的。 解析完了之后就是第四步了，重写ondraw。 12345678910111213141516171819@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); if (itemList != null) &#123; canvas.save(); canvas.scale(SCALE_FATOR, SCALE_FATOR); for (ProvinceItem item : itemList) &#123; //绘制未被选中 if (item != selectedItem) &#123; item.draw(canvas, paint, false); &#125; &#125; //绘制选择的 if (selectedItem != null) &#123; selectedItem.draw(canvas, paint, true); &#125; &#125;&#125; 这里就是很简单的绘制。 第五步。重写onTouchEvent方法。 1234567891011121314151617181920212223242526272829303132333435363738 @Override public boolean onTouchEvent(MotionEvent event) &#123; //将事件转交 return gestureDetectorCompat.onTouchEvent(event); &#125;private void init(Context context) &#123; gestureDetectorCompat = new GestureDetectorCompat(context, new GestureDetector.SimpleOnGestureListener() &#123; @Override public boolean onDown(MotionEvent e) &#123; handlerTouch(e.getX(), e.getY()); return super.onDown(e); &#125; &#125;); &#125; /** * 处理触摸事件的方法 * @param x * @param y */ private void handlerTouch(float x, float y) &#123; if (itemList != null) &#123; ProvinceItem temp = null; for (ProvinceItem item : itemList) &#123; //要除以一个放大系数 if (item.isTouch((int) (x / SCALE_FATOR), (int) (y / SCALE_FATOR))) &#123; temp = item; break; &#125; &#125; if (temp != null) &#123; selectedItem = temp; Toast.makeText(context, \"You click me OVO\", Toast.LENGTH_SHORT).show(); postInvalidate(); &#125; &#125; &#125; 主要就是将down事件转交给gestureDetector来处理，然后写了处理触摸的方法，注意判断点击的xy值需要除以一个放大系数，因为前面放大了canvas，不然会点不到。 好了，以上就是主要的内容了，有什么想看的可以去github看源码，这也是我的学习笔记，发现svg制作复杂的自定义view真的是摔锅神器啊，开玩笑，是大大加快了开发效率。。。","tags":[{"name":"SVG","slug":"SVG","permalink":"https://github.com/LouisShark/tags/SVG/"},{"name":"自定义view","slug":"自定义view","permalink":"https://github.com/LouisShark/tags/自定义view/"}]},{"title":"UI事件传递","date":"2017-05-08T03:46:30.000Z","path":"2017/05/08/UI事件传递/","text":"一些事件传递机制的结论事件传递伪代码：123456789public boolean dispatchTouchEvent(MotionEvent ev) &#123; boolean consume = false; if (onInterceptTouchEvent(ev)) &#123; consume = onTouchEvent(ev); &#125; else &#123; consume = child.dispatchTouchEvent(ev); &#125; return consume;&#125; 一个时间序列是指从手指接触屏幕的那一刻起，到手指离开屏幕的那一刻结束。 正常情况下，一个事件序列只能被一个view拦截且消耗。但可以通过特殊手段做到，比如一个view将本该自己处理的事件通过onTouchEvent强行传递给其他View处理。 某个view一旦决定拦截，那么这一个事件序列都只能由这个view来处理（如果这个事件序列可以传递给他的话），并且它的onInterceptTouchEvent 不会再被调用。 某个view一旦开始处理事件，如果他不消耗ACTION_DOWN 事件(onTouchEvent返回了false)，那么同一事件序列中的其他事件都不会在交给他来处理，并且事件将重新交由它的父元素去处理，即父元素的onTouchEvent会被调用。意思是事件一旦交给一个view处理，那么他必须消耗掉，否则同一事件序列中剩下的事件就不再交给他处理了。 如果View 不消耗除 ACTION_DOWN以外的其他事件，那么这个点击事件会消失，此时父元素的onTouchEvent并不会调用,并且当前View可以持续收到后续的事件，最终这些消失的点击事件会传递给Activity处理。 ViewGroup默认不拦截任何事件。 View 没有onInterceptTouchEvent方法，一旦有事件传递给他，那么它的onTouchEvent方法就会被调用。 View的onTouchEvent默认都会消耗事件（返回true），除非它是不可点击的(clickable和longClickable 同时为false)。 View的enable属性不影响onTouchEvent的默认返回值。哪怕一个view是disable状态的，只要他的clickable或者longClickable有一个为true，那么它的onTouchEvent就返回true。 onClick会发生的前提是当前view是可点击的，并且他收到了down和up事件。 事件传递过程是由外向内的，即事件总是先传递给父元素，然后在由父元素分发给子View，通过requestDisallowInterceptTouchEvent可以在子元素中干预父元素的事件分发过程，但是ACTION_DOWN除外。","tags":[{"name":"UI事件传递","slug":"UI事件传递","permalink":"https://github.com/LouisShark/tags/UI事件传递/"},{"name":"android开发艺术探索","slug":"android开发艺术探索","permalink":"https://github.com/LouisShark/tags/android开发艺术探索/"}]},{"title":"ffmpeg知识点","date":"2017-05-03T16:00:00.000Z","path":"2017/05/04/ffmpeg基础知识和win编译/","text":"libavcodec: 用于各种类型声音/图像编解码 libavutil: 包含一些公共的工具函数 libavformat: 包含多种多媒体容器格式的封装丶解封装工具 libswscale: 用于视频场景的比例缩放丶色彩映射转换 libpostproc: 用于后期效果处理 libavdevice: 用于音视频数据采集和渲染等功能的设备相关 ibswresample: 用于音频重采样和格式转换等功能 libavfilter: 包含多媒体处理常用的滤镜功能 ffmpeg的官方网站是：http://ffmpeg.org/编译好的windows可用版本的下载地址（和官网保持同步）：http://ffmpeg.zeranoe.com/builds/ 该网站中的FFMPEG分为3个版本：Static，Shared，Dev。 前两个版本都可以直接在命令行使用： Static：只有3个应用程序：ffmpeg.exe,ffplay.exe,ffprobe.exe。每个exe的体积都很大，相关的Dll都已经被编译到exe里面去了。Shared : 除了上面那三个exe之外，还有一些Dll，比如avcodec-54.dll之类的。shared里面的exe体积很小，他们运行时到相应的Dll中调用功能。Dev : 用于开发，里面包含了库文件xxx.lib以及头文件xxx.h，这个版本不包含exe文件。 ffmpeg :该项目提供的一个工具，可用于格式转换丶解码或电视卡即时编译等。ffprobe : ffprobe是用于查看文件格式的应用程序。ffplay ：是一个简单的播放器，使用ffmpeg库解析和解码，通过SDL显示ffserver ：一个HTTP多媒体即时广播串流服务器。 常用命令集 获取视频的信息ffmpeg -i video.avi 将图片序列合成视频ffmpeg -f image2 -i image%d.jpg video.mpg上面的命令会把当前目录下的图片（名字如：image1.jpg, image2.jpg等..）合成video.mpg 将视频分解成图片序列ffmpeg -i video.mpg image%d.jpg上面的命令会生成image1.jpg,image2.jpg…支持的图片格式有：PGM,PPM,PAM,PGMYUV,JPEG,GIF,PNG,TIFF,SGI 为视频重新编码以适合在ipod/iphone上播放ffmpeg -i source_video.avi input -acodec aac -ab 128kb -vcodec mpeg4 -b 1200kb -mbd 2 -flags +4mv+trell -aic 2 -cmp 2 -subcmp 2 -s 320x180 -title X final_video.mp4说明： 1234567- 源视频：source_vidro.avi- 音频编码：aac- 音频位率：128kb/s- 视频编码：mpeg4- 视频位率：1200kb/s- 视频尺寸：320 X 180- 生成的视频：final_video.mp4 为视频重新编码以适合在PSP上播放ffmpeg -i source_video.avi -b 300 -s 320x240 -vcodec xvid -ab 32 -ar 24000 -acodec aac final_video.np4说明： 1234567+ 源视频：source_video.avi+ 音频编码：aac+ 音频位率：32kb/s+ 视频编码：xvid+ 视频位率：1200kb/s+ 视频尺寸：320 X 180+ 生成的视频：final_video.mp4 从视频抽出声音。并存为Mp3ffmpeg -i source_video.avi -vn -ar44100 -ac 2 -ab 192 -f mp3 sound.mp3说明： 1234* 源视频：source_video.avi* 音频位率：192kb/s* 输出格式：mp3* 生成的声音：sound.mp3 将wav文件转成Mp3ffmpeg -i son_origine.avi -vn -ar 44100 -ac 2 -ab 192 -f mp3 son_final.mp3 将.avi视频转成.mpgffmpeg -i video_origine.avi video_finale.mpg 将.mpg转成.aviffmpeg -i video_origine.mpg video_finale.avi 将.avi转成gif动画（未压缩）ffmpeg -i video_origine.avi gif_anime.gif 合成视频和音频ffmpeg -i son.wav -i video_origine.avi video_finale.mpg 将.avi转成.flvffmpeg -i video_origine.avi -ab 56 -ar 44100 -b 200 -r 15 -s 320x240 -f flv video_finale.flv 将.avi转成dvffmpeg -i video_origine.avi -s pal -r pal -aspect 4:3 -ar 48000 -ac 2 video_finale.dv或ffmpeg -i video_origine.avi -target pal-dv video_finale.dv 将.avi压缩成divxffmpeg -i video_origine.avi -s 320x240 -vcodec msmpeg4v2 video_finale.avi 将Ogg Theora 压缩成Mpeg dvdffmpeg -i film_sortie_cinelerra.ogm -s 720x576 -vcodec mpeg2video -acodec mp3 film_terminate.mpg 将.avi压缩成SVCD mpeg2NTSC格式：ffmpeg -i video_origine.avi -target ntsc-svcd video_finale.mpgPAL格式：ffmpeg -i video_origine.avi -target pal-svcd video_finale.mpg 将.avi压缩成VCD mpeg2NTSC格式：ffmpeg -i video_origine.avi -target ntsc-vcd video_finale.mpgPAL格式：ffmpeg -i video_origine.avi -traget pal-vcd video_finale.mpg 多通道编码ffmpeg -i fichierentree -pass 2 -passlogfile ffmpeg2pass fichiersortie-2 从flv提取mp3ffmpeg -i source.flv -ab 128k dest.mp3 ##win下编译ffmpeg3.3 下载安装MinGW 下载yasm ffmpeg 编辑ffmpeg文件夹下面的configure文件，找到123456789SLIBNAME_WITH_MAJOR='$(SLIBNAME).$(LIBMAJOR)'LIB_INSTALL_EXTRA_CMD='$$(RANLIB) \"$(LIBDIR)/$(LIBNAME)\"'SLIB_INSTALL_NAME='$(SLIBNAME_WITH_VERSION)'SLIB_INSTALL_LINKS='$(SLIBNAME_WITH_MAJOR) $(SLIBNAME)'将其修改成：SLIBNAME_WITH_MAJOR='$(SLIBPREF)$(FULLNAME)-$(LIBMAJOR)$(SLIBSUF)'LIB_INSTALL_EXTRA_CMD='$$(RANLIB) \"$(LIBDIR)/$(LIBNAME)\"'SLIB_INSTALL_NAME='$(SLIBNAME_WITH_MAJOR)'SLIB_INSTALL_LINKS='$(SLIBNAME)' 新建build_android.sh文件注意：要根据环境配置的前四项，且每行末尾不能有空格。export TMPDIR,NDK,SYSROOT,TOOLCHAIN-cross-prefix 一定有12345678910111213141516171819202122232425262728293031323334#!/bin/bashexport TMPDIR=\"D:\\ffmpeg\\tmp\"NDK=D:\\/sdk\\/ndk-bundleSYSROOT=$NDK/platforms\\/android-24\\/arch-arm/TOOLCHAIN=$NDK/toolchains/arm-linux-androideabi-4.9/prebuilt/windows-x86_64function build_one &#123; ./configure \\ --prefix=$PREFIX \\ --enable-shared \\ --disable-static \\ --disable-doc \\ --disable-ffmpeg \\ --disable-ffplay \\ --disable-ffprobe \\ --disable-ffserver \\ --disable-avdevice \\ --disable-doc \\ --disable-symver \\ --cross-prefix=$TOOLCHAIN/bin/arm-linux-androideabi- \\ --target-os=linux \\ --arch=arm \\ --enable-cross-compile \\ --sysroot=$SYSROOT \\ --extra-cflags=\"-Os -fpic $ADDI_CFLAGS\" \\ --extra-ldflags=\"$ADDI_LDFLAGS\" \\ $ADDITIONAL_CONFIGURE_FLAG make clean make make install &#125; CPU=arm PREFIX=$(pwd)/android/$CPU ADDI_CFLAGS=\"-marm\" build_one 然后在MinGW中cd进ffmpeg目录。命令： chomd 777 ./build_android.sh./build_android.sh 开始编译 编译完成后在FFmpeg下会多一个Android文件夹。","tags":[{"name":"android","slug":"android","permalink":"https://github.com/LouisShark/tags/android/"},{"name":"ffmpeg","slug":"ffmpeg","permalink":"https://github.com/LouisShark/tags/ffmpeg/"}]},{"title":"手动实现arraylist和hashmap","date":"2017-05-02T08:37:26.000Z","path":"2017/05/02/手动实现arraylist和hashmap/","text":"这是第一篇博客，我准备先将最近学习的笔记记录下来，数据结构最基础也最难吧，大佬就别看了。。。 Arraylist public class LouisArraylist&lt;E&gt; { int size; Object[] array; private static final int MIN_CAPACITY_INCREMENT = 12; public LouisArraylist(int capacity){ if(capacity&lt;0){ throw new IllegalArgumentException(); } array = new Object[capacity]; } public LouisArraylist(){ array = new Object[0]; } public LouisArraylist(Collection&lt;? extends E&gt; collection){ Object[] a = collection.toArray(); if(a.getClass()!=Object[].class){ Object[] newArray = new Object[a.length]; System.arraycopy(a, 0, newArray, 0, a.length); a = newArray; } array = a; size = a.length; } /** * 扩容 * */ private static int newCapacity(int currentCapacity){ int increment = (currentCapacity&lt;MIN_CAPACITY_INCREMENT/2)?MIN_CAPACITY_INCREMENT :currentCapacity&gt;&gt;1; return currentCapacity+increment; } /** * 增加 */ public boolean add(E object){ Object[] a = array; int s = size; if(s == a.length){ //需要扩容了 Object[] newArray = new Object[newCapacity(s)]; System.arraycopy(a, 0, newArray, 0, s); array = a = newArray; } a[s] = object; size = s + 1; return true; } public int size(){ return size; } public boolean isEmpty(){ return size==0; } /** * 查找首次出现元素的下标 */ public int indexOf(Object object){ Object[] a = array; int s = size; if(object!=null){ for(int i = 0;i&lt;s;i++){ if(object.equals(a[i])){ return i; } } }else{ for(int i = 0;i&lt;s;i++){ if(a[i] == null){ return i; } } } return -1; } public int lastIndexOf(Object object){ Object[] a = array; int s = size; if(object!=null){ for(int i = s -1;i &gt;= 0;i--){ if(object.equals(a[i])){ return i; } } }else{ for(int i = s -1;i &gt;= 0;i--){ if(a[i] == null){ return i; } } } return -1; } /** * 删除某个元素 */ public E remove(int index){ Object [] a = array; int s = size; if(index &gt;= s){ throw new IndexOutOfBoundsException(); } E e = (E) a[index]; System.arraycopy(a, index+1, a, index, --s-index); a[s] = null; size = s; return e; } /** * 删除某个元素 */ public boolean remove(Object object){ Object[] a = array; int s = size; if (object == null) { for (int i = 0; i &lt; size; i++) { if (a[i] == null) { remove(i); return true; } } } else { for (int i = 0; i &lt; size; i++) { if (a[i].equals(object)) { remove(i); return true; } } } return false; } public E set(int index,E object){ Object[] a = array; if(index&gt;size){ throw new IndexOutOfBoundsException(); } E e = (E) a[index]; a[index] = object; return e; } /** * 获取 */ public E get(int index){ Object[] a = array; if(index&gt;size){ throw new IndexOutOfBoundsException(); } E e = (E) a[index]; return e; } } 代码已经说明的很清楚了，我就不多说什么了，知道底层是数组实现就ok了 HashMap public class LouisHashMap { private int size; private static final int MINIMUN_CAPACITY = 1 &lt;&lt; 2; private static final int MAXNIMUN_CAPACITY = 1 &lt;&lt; 30; //阈值 private int threshhold; //用于强制扩容,因为比minimun还小 private static final Map.Entry[] EMPTY_TABLE = new LouisEntry[MINIMUN_CAPACITY &gt;&gt; 1]; private LouisEntry&lt;K, V&gt;[] table; //核心数组 LouisEntry&lt;K, V&gt; entryOrNullKey; //空键entry public LouisHashMap() { table = (LouisEntry&lt;K, V&gt;[]) EMPTY_TABLE; threshhold = -1; } public LouisHashMap(int capacity) { if (capacity &lt; 0) { throw new IllegalArgumentException(&quot;capacity :&quot; + capacity); } else if (capacity == 0) { table = (LouisEntry&lt;K, V&gt;[]) EMPTY_TABLE; threshhold = -1; return; } else if (capacity &lt; MINIMUN_CAPACITY &amp;&amp; capacity &gt; 0){ capacity = MINIMUN_CAPACITY; } else if (capacity &gt; MAXNIMUN_CAPACITY) { capacity = MAXNIMUN_CAPACITY; } else { capacity = roundUpToPowerOfTwo(capacity); } makeTable(capacity); } /** * 添加 * @param key * @param value * @return */ public V put(K key, V value) { if (key == null) { return putValueForNullKey(value); } int hash = sencondaryHash(key.hashCode()); LouisEntry&lt;K, V&gt;[] tab = table; //将一个很散列的值 位与一个索引大小，会取得0~索引的值 int index = hash &amp; (table.length - 1); //先检查是否存在相同的键 for (LouisEntry&lt;K, V&gt; e = tab[index]; e != null; e = e.next) { //键相同hash值一定相同， hash相同键不一定相同 if (e.hash == hash &amp;&amp; key.equals(e.getKey())) { V oldValue = e.getValue(); e.setValue(value); return oldValue; } } //没有覆盖直接插入元素 if (size++ &gt; threshhold) { //创建一个新的容量的数组 tab = doubleCapacity(); index = hash &amp; (tab.length - 1); } addNewEntry(key, value, hash, index); return null; } private void addNewEntry(K key, V value, int hash, int index) { //将新创建的entry加在链表头，一句代码解决两个事情，放头部，放容易查询也容易 table[index] = new LouisEntry&lt;&gt;(key, value, hash, table[index]); } /** * get * @return */ public V get(Object key) { if (key == null) { LouisEntry&lt;K, V&gt; e = entryOrNullKey; return e == null ? null : e.getValue(); } int hash = sencondaryHash(key.hashCode()); LouisEntry&lt;K, V&gt;[] tab = table; int index = hash &amp; (tab.length - 1); for (LouisEntry&lt;K, V&gt; entry = tab[index]; entry != null; entry = entry.next) { K ekey = entry.key; //比较时，先比较对象值是否相等，在比较属性值是否相等，增加效率 if (ekey == key || (entry.hash == hash &amp;&amp; key.equals(ekey))) { return entry.value; } } return null; } /** * 双倍扩容 * @return */ private LouisEntry&lt;K, V&gt;[] doubleCapacity() { LouisEntry&lt;K, V&gt;[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXNIMUN_CAPACITY) { return oldTable; } //2的幂次方 int newCapacity = oldCapacity &lt;&lt; 1; System.out.println(&quot;扩容：&quot; + size); LouisEntry&lt;K, V&gt;[] newTable = makeTable(newCapacity); if (size == 0) { return newTable; } //开始重新散列 for (int j = 0; j &lt; oldTable.length; j++) { LouisEntry&lt;K, V&gt; e = oldTable[j]; //拿到每个键值对 if (e == null) { continue; //因为每个索引不一定有值，hash } // 与上面 int index = hash &amp; (table.length - 1);会出现两组数据，一种还在远处，一种去到length的位置 int highBit = e.hash &amp; oldCapacity; LouisEntry&lt;K, V&gt; broken = null; //位或 运算最多是原值的两倍，重新一次散列 newTable[j | highBit] = e; for (LouisEntry&lt;K, V&gt; n = e.next; n != null; e = n, n = n.next) { //n 为当前遍历的元素， e为前一个 int nextHighBit = n.hash &amp; oldCapacity; if (nextHighBit != highBit) { if (broken == null) { int nextNewIndex = j | nextHighBit; //新的索引的位置 newTable[nextNewIndex] = n; } else { broken.next = n; } broken = e; highBit = nextHighBit; } } if (broken != null) { broken.next = null; } } return newTable; } /** * hashMap键的hash算法 * @param h * @return */ private int sencondaryHash(int h) { h ^= (h&gt;&gt;&gt;20)^(h&gt;&gt;&gt;12); return h^(h&gt;&gt;&gt;7)^(h&gt;&gt;&gt;4); } /** * 放空键的键值对 * @param value * @return */ private V putValueForNullKey(V value) { LouisEntry&lt;K, V&gt; entry = entryOrNullKey; if (entry == null) { addNewEntryForNullKey(value); size++; return null; } else{ V oldValue = entry.getValue(); entry.setValue(value); return oldValue; } } private void addNewEntryForNullKey(V value) { entryOrNullKey = new LouisEntry&lt;K, V&gt;(null, value, 0, null); } /** * 根据容量创建核心数组 * @param capacity */ private LouisEntry&lt;K, V&gt;[] makeTable(int capacity) { LouisEntry&lt;K, V&gt;[] newTable = new LouisEntry[capacity]; table = newTable; threshhold = (capacity &gt;&gt;&gt; 2) + (capacity &gt;&gt;&gt; 1); return newTable; } private int roundUpToPowerOfTwo(int i) { i--; i |= i &gt;&gt;&gt; 1; // i = i | (i &gt;&gt;&gt; 1) 让所有的位都变成 1 ， 最后在加 1，就可以被2整除 i |= i &gt;&gt;&gt; 2; i |= i &gt;&gt;&gt; 4; i |= i &gt;&gt;&gt; 8; i |= i &gt;&gt;&gt; 16; return i + 1; } public int getSize() { return size; } /** * 键值对类 * @param &lt;K&gt; * @param &lt;V&gt; */ static class LouisEntry&lt;K, V&gt; implements Map.Entry&lt;K, V&gt; { final int hash; final K key; //此处用final 只赋值一次，因为key是唯一的 V value; LouisEntry&lt;K, V&gt; next; public LouisEntry(K key, V value, int hash, LouisEntry&lt;K, V&gt; next) { this.key = key; this.value = value; this.hash = hash; this.next = next; } @Override public K getKey() { return key; } @Override public V getValue() { return value; } @Override public V setValue(V value) { V oldValue = this.value; this.value = value; return oldValue; } @Override public int hashCode() { // ^ 异或运算使结果更加散列，相同为0 return (key == null ? 0 :key.hashCode()) ^ (value == null ? 0 : value.hashCode()); } } } 第一次写博客，注释也很多了，兄弟们自己将就看吧。","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://github.com/LouisShark/tags/数据结构/"},{"name":"java","slug":"java","permalink":"https://github.com/LouisShark/tags/java/"}]},{"title":"Hello World","date":"2017-04-19T09:58:12.666Z","path":"2017/04/19/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]