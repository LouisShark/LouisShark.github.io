[{"title":"ffmpeg知识点","date":"2017-06-23T09:29:00.000Z","path":"2017/06/23/AppCompatActivity的作用分析/","text":"AppCompatActivity的作用分析 对于v7包下的AppCompatActivity，我是比较晚入的android(并不知道是不是坑)，所以一开始就用的as创建项目就很奇怪为什么我的activity自动继承了AppCompatActivity，不是应该继承Activity吗？Ecm？我仿佛感觉受到了欺骗，于是就对其进行了研究(就是看源码拉)。(因为当时是边看边解析边写的，所以思路可能有点乱，自己再看一遍源码更好，也是学习的一部分) 一开始我就发现了v4 v7 v13等等的support库，然后发现这些库是用来解决兼容问题的，数字分别对应了android的API版本，即分别适配android版本4，7，13以上的app。看完之后发现google程序员为了适配也是良苦用心啊。 从AppCompatActivity源码的onCreate看到这个类初始化的第一步就调用了getDelegate获得了一个代理，并且你会发现下面所有的生命周期的方法都交由这个代理类来实现了，那么这个东西是什么呢？其实就是AppCompatDelegate这个抽象类。 1234567891011121314151617181920212223242526272829 @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; final AppCompatDelegate delegate = getDelegate(); delegate.installViewFactory(); delegate.onCreate(savedInstanceState); if (delegate.applyDayNight() &amp;&amp; mThemeId != 0) &#123; // If DayNight has been applied, we need to re-apply the theme for // the changes to take effect. On API 23+, we should bypass // setTheme(), which will no-op if the theme ID is identical to the // current theme ID. if (Build.VERSION.SDK_INT &gt;= 23) &#123; onApplyThemeResource(getTheme(), mThemeId, false); &#125; else &#123; setTheme(mThemeId); &#125; &#125; super.onCreate(savedInstanceState); &#125;/** * @return The &#123;@link AppCompatDelegate&#125; being used by this Activity. */ @NonNull public AppCompatDelegate getDelegate() &#123; if (mDelegate == null) &#123; mDelegate = AppCompatDelegate.create(this, this); &#125; return mDelegate; &#125; 那么AppCompatDelegate这个类到底做了什么呢？点进去看这个create方法 123public static AppCompatDelegate create(Activity activity, AppCompatCallback callback) &#123; return create(activity, activity.getWindow(), callback);&#125; 然后调用： 123456789101112131415private static AppCompatDelegate create(Context context, Window window, AppCompatCallback callback) &#123; final int sdk = Build.VERSION.SDK_INT; if (BuildCompat.isAtLeastN()) &#123; return new AppCompatDelegateImplN(context, window, callback); &#125; else if (sdk &gt;= 23) &#123; return new AppCompatDelegateImplV23(context, window, callback); &#125; else if (sdk &gt;= 14) &#123; return new AppCompatDelegateImplV14(context, window, callback); &#125; else if (sdk &gt;= 11) &#123; return new AppCompatDelegateImplV11(context, window, callback); &#125; else &#123; return new AppCompatDelegateImplV9(context, window, callback); &#125;&#125; 是不是感觉这些名字有点熟悉呢。 这个方法返回了一些根据版本号的实现类。 下面我将给出这个抽象类的类之间的继承关系： 在as 中使用ctrl + H的快捷键可以很快的看到类之间的继承图。 发现他们之间相互继承，于是开始看V9的源码，找到了一个可疑的方法： 12345678910111213141516171819202122232425262728293031323334/** 这个方法会(invoke) &#123;当我们使用自己的layoutInflater的factory的时候&#125; */ @Override public View createView(View parent, final String name, @NonNull Context context, @NonNull AttributeSet attrs) &#123; final boolean isPre21 = Build.VERSION.SDK_INT &lt; 21; if (mAppCompatViewInflater == null) &#123; mAppCompatViewInflater = new AppCompatViewInflater(); &#125; // We only want the View to inherit its context if we're running pre-v21 final boolean inheritContext = isPre21 &amp;&amp; shouldInheritContext((ViewParent) parent); return mAppCompatViewInflater.createView(parent, name, context, attrs, inheritContext, isPre21, /* Only read android:theme pre-L (L+ handles this anyway) */ true, /* Read read app:theme as a fallback at all times for legacy reasons */ VectorEnabledTintResources.shouldBeUsed() /* Only tint wrap the context if enabled */ ); &#125; @Override public void installViewFactory() &#123; LayoutInflater layoutInflater = LayoutInflater.from(mContext); if (layoutInflater.getFactory() == null) &#123; LayoutInflaterCompat.setFactory(layoutInflater, this); &#125; else &#123; if (!(LayoutInflaterCompat.getFactory(layoutInflater) instanceof AppCompatDelegateImplV9)) &#123; Log.i(TAG, \"The Activity's LayoutInflater already has a Factory installed\" + \" so we can not install AppCompat's\"); &#125; &#125; &#125; 突然想起来一句话，兼容问题其实就是着色问题，AppCompatDelegate 的工作就是涂色。发现这个方法在AppCompatDelegate里面定义的，别问我怎么找到的，你在V9这个类看到1000多行代码的时候找到了，然后我跑回去看AppCompatDelegate这个类里面的方法。 12345678910111213141516171819202122232425262728293031/** * Installs AppCompat's &#123;@link android.view.LayoutInflater&#125; Factory so that it can replace * the framework widgets with compatible tinted versions. This should be called before * &#123;@code super.onCreate()&#125; as so: * &lt;pre class=\"prettyprint\"&gt; * protected void onCreate(Bundle savedInstanceState) &#123; * getDelegate().installViewFactory(); * getDelegate().onCreate(savedInstanceState); * super.onCreate(savedInstanceState); * * // ... * &#125; * &lt;/pre&gt; * If you are using your own &#123;@link android.view.LayoutInflater.Factory Factory&#125; or * &#123;@link android.view.LayoutInflater.Factory2 Factory2&#125; then you can omit this call, and instead call * &#123;@link #createView(android.view.View, String, android.content.Context, android.util.AttributeSet)&#125; * from your factory to return any compatible widgets. */ public abstract void installViewFactory(); /** * This should be called from a * &#123;@link android.view.LayoutInflater.Factory2 LayoutInflater.Factory2&#125; in order * to return tint-aware widgets. * &lt;p&gt; * This is only needed if you are using your own * &#123;@link android.view.LayoutInflater LayoutInflater&#125; factory, and have therefore not * installed the default factory via &#123;@link #installViewFactory()&#125;. */ public abstract View createView(@Nullable View parent, String name, @NonNull Context context, @NonNull AttributeSet attrs); 看到上面的注释我突然顿悟了，找了半天的在哪里设置的layoutInflater的factory，原来是这样子，于是又去AppCompatActivity瞅了一眼： 12345protected void onCreate(@Nullable Bundle savedInstanceState) &#123; final AppCompatDelegate delegate = getDelegate(); delegate.installViewFactory(); delegate.onCreate(savedInstanceState); &#125; 发现onCreate方法里果然有这句话，installViewFactory()；这个方法就是给The Activity’s LayoutInflater设置一个自己的factory，于是就会调用createView这个方法 注意createView里面的这句话： 12345return mAppCompatViewInflater.createView(parent, name, context, attrs, inheritContext, isPre21, /* Only read android:theme pre-L (L+ handles this anyway) */ true, /* Read read app:theme as a fallback at all times for legacy reasons */ VectorEnabledTintResources.shouldBeUsed() /* Only tint wrap the context if enabled */ ); 于是跑到AppCompatViewInflater的createView方法看，终于找到了： 123456789101112131415161718192021222324252627282930313233343536373839404142// We need to 'inject' our tint aware Views in place of the standard framework versions switch (name) &#123; case \"TextView\": view = new AppCompatTextView(context, attrs); break; case \"ImageView\": view = new AppCompatImageView(context, attrs); break; case \"Button\": view = new AppCompatButton(context, attrs); break; case \"EditText\": view = new AppCompatEditText(context, attrs); break; case \"Spinner\": view = new AppCompatSpinner(context, attrs); break; case \"ImageButton\": view = new AppCompatImageButton(context, attrs); break; case \"CheckBox\": view = new AppCompatCheckBox(context, attrs); break; case \"RadioButton\": view = new AppCompatRadioButton(context, attrs); break; case \"CheckedTextView\": view = new AppCompatCheckedTextView(context, attrs); break; case \"AutoCompleteTextView\": view = new AppCompatAutoCompleteTextView(context, attrs); break; case \"MultiAutoCompleteTextView\": view = new AppCompatMultiAutoCompleteTextView(context, attrs); break; case \"RatingBar\": view = new AppCompatRatingBar(context, attrs); break; case \"SeekBar\": view = new AppCompatSeekBar(context, attrs); break; &#125; 原来在activity的oncreate一开始创建的时候，系统就自动帮我们把这些色调给我们换掉了所以你写在XML的控件，都会被换成AppCompat开头的兼容性的控件，当然前提是你要继承AppCompatActivity，这就是系统为我们所做的适配了，请注意，AppCompatViewInflater也给我们提供了一个热换肤的思路，下次有时间再说吧。 总结起来，这个兼容其实就是偷梁换柱，而且看源码一定不能被细枝末节影响，像我一样，如果我能做点笔记，而不是草率的开始，应该过程会更加的轻松。","tags":[{"name":"源码分析","slug":"源码分析","permalink":"https://github.com/LouisShark/tags/源码分析/"},{"name":"android","slug":"android","permalink":"https://github.com/LouisShark/tags/android/"}]},{"title":"滑动冲突的解决方式","date":"2017-06-14T03:04:10.000Z","path":"2017/06/14/滑动冲突的解决方式/","text":"外部拦截法 即指点击事件都先经过父容器的拦截处理，如果父容器需要此事件就拦截，如果不需要此事件就不拦截，这样就可以解决滑动冲突的问题，这种方法比较符合点击事件的分发机制。外部拦截法要重写父容器的onInterceptTouchEvent方法，并在内部做相应的拦截。伪代码如下： 1234567891011121314151617181920212223242526@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) &#123; boolean intercepted = false; int x = (int) ev.getX(); int y = (int) ev.getY(); switch (ev.getAction()) &#123; case MotionEvent.ACTION_DOWN: intercepted = false; break; case MotionEvent.ACTION_MOVE: if (父容器需要当前点击事件)&#123; intercepted = true; &#125; else &#123; intercepted = false; &#125; break; case MotionEvent.ACTION_UP: intercepted = false; break; default: break; &#125; mLastXIntercept = x; mLastYIntercept = y; return intercepted;&#125; 上述代码是外部拦截法的典型逻辑，针对不同的滑动冲突，只需要修改父容器需要当前点击事件这个条件即可，其他均不需并且也不能修改。 对上述代码进行讲解： ​ ACTION_DOWN事件返回false，因为父容器拦截了down事件，后续的action_move和action_up事件都会直接 交由父容器处理，事件无法传递给子元素.​ ACTION_MOVE事件，可以根据需要来决定是否拦截，如果父容器拦截就返回true，不拦截就返回false。​ ACTION_UP事件，必须返回false，因为up事件本身并没有多大的意义。 考虑一种情况，假设事件交由子元素处理，如果父容器在ACTION_UP时返回了true，就会导致子元素无法接收到ACTION_UP事件，这个时候子元素中的onclick事件就无法触发，但是父容器比较特殊，一旦它开始拦截任何一个事件，那么后续的事件都会交由它来处理，而ACTION_UP作为最后一个事件也必定可以传递给父容器，即使父容器的onInterceptTouchEvent方法在ACTION_UP时返回了false. 内部拦截法 内部拦截法是指父容器不拦截任何事件，所有的事件都传递给子元素，如果子元素需要此事件就直接消耗掉，否则就交由父容器进行处理，这种方法和android中的事件分发机制就不一样，需要配合requestDisallowInterceptTouchEvent方法才能正常工作，使用起来比外部拦截法稍显复杂。伪代码如下： 1234567891011121314151617181920212223242526@Overridepublic boolean dispatchTouchEvent(MotionEvent event) &#123; int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: parent.requestDisallowInterceptTouchEvent(true); break; case MotionEvent.ACTION_MOVE: int deltaX = x - mLastX; int deltaY = y - mLastY; if (父容器需要此类点击事件) &#123; parent.requestDisallowInterceptTouchEvent(false); &#125; break; case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: break; default: break; &#125; mLastX = x; mLastY = y; return super.dispatchTouchEvent(event);&#125; 上述代码是内部拦截法的典型代码，当面对不同的滑动策略时只需要修改里面1的条件即可，其他不需要做改动也不需要做改动。除了子元素需要做处理以外，父元素也要默认拦截除了ACTION_DOWN以外的其他事件，这样当子元素调用parent.requestDisallowInterceptTouchEvent(false)方法时，父元素才能继续拦截所需的事件。 为什么父容器不能拦截ACTION_DOWN事件呢，因为这个事件不受FLAG_DISALLOW_INTERCEPT这个标记位的控制，所以一旦父容器拦截ACTION_DOWN事件了，那么所有的事件都无法传递到子元素去，这样内部拦截法就无法起作用了。 父元素的修改如下： 12345678910@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) &#123; int action = ev.getAction(); if (action == MotionEvent.ACTION_DOWN) &#123; return false; &#125; else &#123; return true; &#125;&#125; ​","tags":[{"name":"自定义view","slug":"自定义view","permalink":"https://github.com/LouisShark/tags/自定义view/"},{"name":"滑动冲突","slug":"滑动冲突","permalink":"https://github.com/LouisShark/tags/滑动冲突/"},{"name":"事件分发","slug":"事件分发","permalink":"https://github.com/LouisShark/tags/事件分发/"}]},{"title":"使用SVG来实现复杂的自定义View","date":"2017-06-02T01:48:53.000Z","path":"2017/06/02/使用SVG来实现复杂的自定义View/","text":"最近发现可以用SVG来实习非常复杂的自定义View，可以说是非常的厉害了。只要你看到不想做的很复杂的设计图，你就让美工妹子给你来一张SVG吧，还可以趁机和她聊下天。 我们就来画一个可交互的中国台湾地图吧，首先我们来理一下做这种自定义View的步骤。 下载含有中国地图的 SVG 用此 网站 将svg资源转换成相应的 Android代码 利用Xml解析SVG的代码 封装成javaBean 最重要的得到Path 重写OnDraw方法 利用Path绘制中国地图 重写OnTouchEvent方法，记录手指触摸位置，判断这个位置是否坐落在某个省份上 对了，地图资源可以在这里 下载。开始写代码吧。 项目地址点这里可以看源码。 前两步不需要我如何说了吧，可以把转化后的android代码，放入res/raw目录下，接下来开始第三步： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private void parseXMLWithPull() &#123; InputStream inputStream = null; try &#123; inputStream = context.getResources().openRawResource(R.raw.taiwanhigh); XmlPullParserFactory factory = XmlPullParserFactory.newInstance(); factory.setNamespaceAware(true); XmlPullParser xmlPullParser = factory.newPullParser(); xmlPullParser.setInput(inputStream, \"UTF-8\"); int eventType = xmlPullParser.getEventType(); ProvinceItem item = null; while (eventType != XmlPullParser.END_DOCUMENT) &#123; String nodeName = xmlPullParser.getName(); switch (eventType) &#123; //开始解析某个节点 case XmlPullParser.START_DOCUMENT: itemList = new ArrayList&lt;&gt;(); break; case XmlPullParser.START_TAG: if (\"path\".equals(nodeName)) &#123; String pathData = xmlPullParser.getAttributeValue(\"http://schemas.android.com/apk/res/android\", \"pathData\"); Path path = PathParser.createPathFromPathData(pathData); item = new ProvinceItem(path); &#125; break; case XmlPullParser.END_TAG: if (nodeName.equalsIgnoreCase(\"path\") &amp;&amp; item != null) &#123; assert itemList != null; itemList.add(item); item = null; handler.sendEmptyMessage(PARSE_END); &#125; break; default: break; &#125; eventType = xmlPullParser.next(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (inputStream != null) &#123; try &#123; inputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; xml解析写的非常随便，如果有需要修改的请自行修改，这里主要的是将解析出来的path标签下的pathData，然后使用封装好的PathParser(这个类大家可以自己去搜索下载)来将pathData封装成path，然后将path传入ProvinceItem类生成java bean类。下面我们来看一下这个Bean类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/* 路径 */ private Path path; /* 绘制颜色 */ private int drawColor; public ProvinceItem(Path path) &#123; this.path = path; &#125; /** * 自绘 * @param canvas * @param paint * @param isSelect */ public void draw(Canvas canvas, Paint paint, boolean isSelect) &#123; if (isSelect) &#123; //绘制背景 paint.setStrokeWidth(2); paint.setColor(Color.BLACK); paint.setStyle(Paint.Style.FILL); paint.setShadowLayer(8, 0, 0, 0xffffffff); canvas.drawPath(path, paint); //绘制省份 paint.clearShadowLayer(); paint.setColor(drawColor); paint.setStyle(Paint.Style.FILL); paint.setStrokeWidth(2); canvas.drawPath(path, paint); &#125; else &#123; //没有被选择的时候绘制内容 paint.clearShadowLayer(); paint.setColor(drawColor); paint.setStyle(Paint.Style.FILL); paint.setStrokeWidth(1); canvas.drawPath(path, paint); //选择的时候绘制边界线 paint.setStyle(Paint.Style.STROKE); paint.setColor(0XFFEEEEEE); canvas.drawPath(path, paint); &#125; &#125; /* 判断是否点击了省份 */ public boolean isTouch(int x, int y) &#123; RectF rectF = new RectF(); //就是用path的四个点生成一个rectf path.computeBounds(rectF, true); Region region = new Region(); //setPath 就是用path在region里面剪切出一个区域 region.setPath(path, new Region((int) rectF.left, (int) rectF.top, (int) rectF.right, (int) rectF.bottom)); return region.contains(x, y); &#125; 这个类主要就是两个方法，draw方法和isTouch方法，下面来说这两个方法的作用： drawdraw方法主要是传递三个参数来进行自绘： canvas 画板 paint 画笔 isSelect 是否被选中 因为这个方法用来处理被点击时界面的变化，未选中和被选中的效果是不一样的。 此处可以自己来随便写。 isTouch这个方法判断这个区域是否被选中，当然也可以有其他的方法来判断是否被点击，这里提供一种思路，主要是region里面的setPath方法，我们点进去源码看一下 12345678910&gt; /**&gt; * Set the region to the area described by the path and clip.&gt; * Return true if the resulting region is non-empty. This produces a region&gt; * that is identical to the pixels that would be drawn by the path&gt; * (with no antialiasing).&gt; */&gt; public boolean setPath(Path path, Region clip) &#123;&gt; return nativeSetPath(mNativeRegion, path.readOnlyNI(), clip.mNativeRegion);&gt; &#125;&gt; &gt; 大概的意思就是用这个path在region裁剪出一个region，这个区域就是省份的区域，是不规则的。 解析完了之后就是第四步了，重写ondraw。 12345678910111213141516171819@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); if (itemList != null) &#123; canvas.save(); canvas.scale(SCALE_FATOR, SCALE_FATOR); for (ProvinceItem item : itemList) &#123; //绘制未被选中 if (item != selectedItem) &#123; item.draw(canvas, paint, false); &#125; &#125; //绘制选择的 if (selectedItem != null) &#123; selectedItem.draw(canvas, paint, true); &#125; &#125;&#125; 这里就是很简单的绘制。 第五步。重写onTouchEvent方法。 1234567891011121314151617181920212223242526272829303132333435363738 @Override public boolean onTouchEvent(MotionEvent event) &#123; //将事件转交 return gestureDetectorCompat.onTouchEvent(event); &#125;private void init(Context context) &#123; gestureDetectorCompat = new GestureDetectorCompat(context, new GestureDetector.SimpleOnGestureListener() &#123; @Override public boolean onDown(MotionEvent e) &#123; handlerTouch(e.getX(), e.getY()); return super.onDown(e); &#125; &#125;); &#125; /** * 处理触摸事件的方法 * @param x * @param y */ private void handlerTouch(float x, float y) &#123; if (itemList != null) &#123; ProvinceItem temp = null; for (ProvinceItem item : itemList) &#123; //要除以一个放大系数 if (item.isTouch((int) (x / SCALE_FATOR), (int) (y / SCALE_FATOR))) &#123; temp = item; break; &#125; &#125; if (temp != null) &#123; selectedItem = temp; Toast.makeText(context, \"You click me OVO\", Toast.LENGTH_SHORT).show(); postInvalidate(); &#125; &#125; &#125; 主要就是将down事件转交给gestureDetector来处理，然后写了处理触摸的方法，注意判断点击的xy值需要除以一个放大系数，因为前面放大了canvas，不然会点不到。 好了，以上就是主要的内容了，有什么想看的可以去github看源码，这也是我的学习笔记，发现svg制作复杂的自定义view真的是摔锅神器啊，开玩笑，是大大加快了开发效率。。。","tags":[{"name":"SVG","slug":"SVG","permalink":"https://github.com/LouisShark/tags/SVG/"},{"name":"自定义view","slug":"自定义view","permalink":"https://github.com/LouisShark/tags/自定义view/"}]},{"title":"UI事件传递","date":"2017-05-08T03:46:30.000Z","path":"2017/05/08/UI事件传递/","text":"一些事件传递机制的结论事件传递伪代码：123456789public boolean dispatchTouchEvent(MotionEvent ev) &#123; boolean consume = false; if (onInterceptTouchEvent(ev)) &#123; consume = onTouchEvent(ev); &#125; else &#123; consume = child.dispatchTouchEvent(ev); &#125; return consume;&#125; 一个时间序列是指从手指接触屏幕的那一刻起，到手指离开屏幕的那一刻结束。 正常情况下，一个事件序列只能被一个view拦截且消耗。但可以通过特殊手段做到，比如一个view将本该自己处理的事件通过onTouchEvent强行传递给其他View处理。 某个view一旦决定拦截，那么这一个事件序列都只能由这个view来处理（如果这个事件序列可以传递给他的话），并且它的onInterceptTouchEvent 不会再被调用。 某个view一旦开始处理事件，如果他不消耗ACTION_DOWN 事件(onTouchEvent返回了false)，那么同一事件序列中的其他事件都不会在交给他来处理，并且事件将重新交由它的父元素去处理，即父元素的onTouchEvent会被调用。意思是事件一旦交给一个view处理，那么他必须消耗掉，否则同一事件序列中剩下的事件就不再交给他处理了。 如果View 不消耗除 ACTION_DOWN以外的其他事件，那么这个点击事件会消失，此时父元素的onTouchEvent并不会调用,并且当前View可以持续收到后续的事件，最终这些消失的点击事件会传递给Activity处理。 ViewGroup默认不拦截任何事件。 View 没有onInterceptTouchEvent方法，一旦有事件传递给他，那么它的onTouchEvent方法就会被调用。 View的onTouchEvent默认都会消耗事件（返回true），除非它是不可点击的(clickable和longClickable 同时为false)。 View的enable属性不影响onTouchEvent的默认返回值。哪怕一个view是disable状态的，只要他的clickable或者longClickable有一个为true，那么它的onTouchEvent就返回true。 onClick会发生的前提是当前view是可点击的，并且他收到了down和up事件。 事件传递过程是由外向内的，即事件总是先传递给父元素，然后在由父元素分发给子View，通过requestDisallowInterceptTouchEvent可以在子元素中干预父元素的事件分发过程，但是ACTION_DOWN除外。","tags":[{"name":"UI事件传递","slug":"UI事件传递","permalink":"https://github.com/LouisShark/tags/UI事件传递/"},{"name":"android开发艺术探索","slug":"android开发艺术探索","permalink":"https://github.com/LouisShark/tags/android开发艺术探索/"}]},{"title":"ffmpeg知识点","date":"2017-05-03T16:00:00.000Z","path":"2017/05/04/ffmpeg基础知识和win编译/","text":"libavcodec: 用于各种类型声音/图像编解码 libavutil: 包含一些公共的工具函数 libavformat: 包含多种多媒体容器格式的封装丶解封装工具 libswscale: 用于视频场景的比例缩放丶色彩映射转换 libpostproc: 用于后期效果处理 libavdevice: 用于音视频数据采集和渲染等功能的设备相关 ibswresample: 用于音频重采样和格式转换等功能 libavfilter: 包含多媒体处理常用的滤镜功能 ffmpeg的官方网站是：http://ffmpeg.org/编译好的windows可用版本的下载地址（和官网保持同步）：http://ffmpeg.zeranoe.com/builds/ 该网站中的FFMPEG分为3个版本：Static，Shared，Dev。 前两个版本都可以直接在命令行使用： Static：只有3个应用程序：ffmpeg.exe,ffplay.exe,ffprobe.exe。每个exe的体积都很大，相关的Dll都已经被编译到exe里面去了。Shared : 除了上面那三个exe之外，还有一些Dll，比如avcodec-54.dll之类的。shared里面的exe体积很小，他们运行时到相应的Dll中调用功能。Dev : 用于开发，里面包含了库文件xxx.lib以及头文件xxx.h，这个版本不包含exe文件。 ffmpeg :该项目提供的一个工具，可用于格式转换丶解码或电视卡即时编译等。ffprobe : ffprobe是用于查看文件格式的应用程序。ffplay ：是一个简单的播放器，使用ffmpeg库解析和解码，通过SDL显示ffserver ：一个HTTP多媒体即时广播串流服务器。 常用命令集 获取视频的信息ffmpeg -i video.avi 将图片序列合成视频ffmpeg -f image2 -i image%d.jpg video.mpg上面的命令会把当前目录下的图片（名字如：image1.jpg, image2.jpg等..）合成video.mpg 将视频分解成图片序列ffmpeg -i video.mpg image%d.jpg上面的命令会生成image1.jpg,image2.jpg…支持的图片格式有：PGM,PPM,PAM,PGMYUV,JPEG,GIF,PNG,TIFF,SGI 为视频重新编码以适合在ipod/iphone上播放ffmpeg -i source_video.avi input -acodec aac -ab 128kb -vcodec mpeg4 -b 1200kb -mbd 2 -flags +4mv+trell -aic 2 -cmp 2 -subcmp 2 -s 320x180 -title X final_video.mp4说明： 1234567- 源视频：source_vidro.avi- 音频编码：aac- 音频位率：128kb/s- 视频编码：mpeg4- 视频位率：1200kb/s- 视频尺寸：320 X 180- 生成的视频：final_video.mp4 为视频重新编码以适合在PSP上播放ffmpeg -i source_video.avi -b 300 -s 320x240 -vcodec xvid -ab 32 -ar 24000 -acodec aac final_video.np4说明： 1234567+ 源视频：source_video.avi+ 音频编码：aac+ 音频位率：32kb/s+ 视频编码：xvid+ 视频位率：1200kb/s+ 视频尺寸：320 X 180+ 生成的视频：final_video.mp4 从视频抽出声音。并存为Mp3ffmpeg -i source_video.avi -vn -ar44100 -ac 2 -ab 192 -f mp3 sound.mp3说明： 1234* 源视频：source_video.avi* 音频位率：192kb/s* 输出格式：mp3* 生成的声音：sound.mp3 将wav文件转成Mp3ffmpeg -i son_origine.avi -vn -ar 44100 -ac 2 -ab 192 -f mp3 son_final.mp3 将.avi视频转成.mpgffmpeg -i video_origine.avi video_finale.mpg 将.mpg转成.aviffmpeg -i video_origine.mpg video_finale.avi 将.avi转成gif动画（未压缩）ffmpeg -i video_origine.avi gif_anime.gif 合成视频和音频ffmpeg -i son.wav -i video_origine.avi video_finale.mpg 将.avi转成.flvffmpeg -i video_origine.avi -ab 56 -ar 44100 -b 200 -r 15 -s 320x240 -f flv video_finale.flv 将.avi转成dvffmpeg -i video_origine.avi -s pal -r pal -aspect 4:3 -ar 48000 -ac 2 video_finale.dv或ffmpeg -i video_origine.avi -target pal-dv video_finale.dv 将.avi压缩成divxffmpeg -i video_origine.avi -s 320x240 -vcodec msmpeg4v2 video_finale.avi 将Ogg Theora 压缩成Mpeg dvdffmpeg -i film_sortie_cinelerra.ogm -s 720x576 -vcodec mpeg2video -acodec mp3 film_terminate.mpg 将.avi压缩成SVCD mpeg2NTSC格式：ffmpeg -i video_origine.avi -target ntsc-svcd video_finale.mpgPAL格式：ffmpeg -i video_origine.avi -target pal-svcd video_finale.mpg 将.avi压缩成VCD mpeg2NTSC格式：ffmpeg -i video_origine.avi -target ntsc-vcd video_finale.mpgPAL格式：ffmpeg -i video_origine.avi -traget pal-vcd video_finale.mpg 多通道编码ffmpeg -i fichierentree -pass 2 -passlogfile ffmpeg2pass fichiersortie-2 从flv提取mp3ffmpeg -i source.flv -ab 128k dest.mp3 ##win下编译ffmpeg3.3 下载安装MinGW 下载yasm ffmpeg 编辑ffmpeg文件夹下面的configure文件，找到123456789SLIBNAME_WITH_MAJOR='$(SLIBNAME).$(LIBMAJOR)'LIB_INSTALL_EXTRA_CMD='$$(RANLIB) \"$(LIBDIR)/$(LIBNAME)\"'SLIB_INSTALL_NAME='$(SLIBNAME_WITH_VERSION)'SLIB_INSTALL_LINKS='$(SLIBNAME_WITH_MAJOR) $(SLIBNAME)'将其修改成：SLIBNAME_WITH_MAJOR='$(SLIBPREF)$(FULLNAME)-$(LIBMAJOR)$(SLIBSUF)'LIB_INSTALL_EXTRA_CMD='$$(RANLIB) \"$(LIBDIR)/$(LIBNAME)\"'SLIB_INSTALL_NAME='$(SLIBNAME_WITH_MAJOR)'SLIB_INSTALL_LINKS='$(SLIBNAME)' 新建build_android.sh文件注意：要根据环境配置的前四项，且每行末尾不能有空格。export TMPDIR,NDK,SYSROOT,TOOLCHAIN-cross-prefix 一定有12345678910111213141516171819202122232425262728293031323334#!/bin/bashexport TMPDIR=\"D:\\ffmpeg\\tmp\"NDK=D:\\/sdk\\/ndk-bundleSYSROOT=$NDK/platforms\\/android-24\\/arch-arm/TOOLCHAIN=$NDK/toolchains/arm-linux-androideabi-4.9/prebuilt/windows-x86_64function build_one &#123; ./configure \\ --prefix=$PREFIX \\ --enable-shared \\ --disable-static \\ --disable-doc \\ --disable-ffmpeg \\ --disable-ffplay \\ --disable-ffprobe \\ --disable-ffserver \\ --disable-avdevice \\ --disable-doc \\ --disable-symver \\ --cross-prefix=$TOOLCHAIN/bin/arm-linux-androideabi- \\ --target-os=linux \\ --arch=arm \\ --enable-cross-compile \\ --sysroot=$SYSROOT \\ --extra-cflags=\"-Os -fpic $ADDI_CFLAGS\" \\ --extra-ldflags=\"$ADDI_LDFLAGS\" \\ $ADDITIONAL_CONFIGURE_FLAG make clean make make install &#125; CPU=arm PREFIX=$(pwd)/android/$CPU ADDI_CFLAGS=\"-marm\" build_one 然后在MinGW中cd进ffmpeg目录。命令： chomd 777 ./build_android.sh./build_android.sh 开始编译 编译完成后在FFmpeg下会多一个Android文件夹。","tags":[{"name":"android","slug":"android","permalink":"https://github.com/LouisShark/tags/android/"},{"name":"ffmpeg","slug":"ffmpeg","permalink":"https://github.com/LouisShark/tags/ffmpeg/"}]},{"title":"手动实现arraylist和hashmap","date":"2017-05-02T08:37:26.000Z","path":"2017/05/02/手动实现arraylist和hashmap/","text":"这是第一篇博客，我准备先将最近学习的笔记记录下来，数据结构最基础也最难吧，大佬就别看了。。。 Arraylist public class LouisArraylist&lt;E&gt; { int size; Object[] array; private static final int MIN_CAPACITY_INCREMENT = 12; public LouisArraylist(int capacity){ if(capacity&lt;0){ throw new IllegalArgumentException(); } array = new Object[capacity]; } public LouisArraylist(){ array = new Object[0]; } public LouisArraylist(Collection&lt;? extends E&gt; collection){ Object[] a = collection.toArray(); if(a.getClass()!=Object[].class){ Object[] newArray = new Object[a.length]; System.arraycopy(a, 0, newArray, 0, a.length); a = newArray; } array = a; size = a.length; } /** * 扩容 * */ private static int newCapacity(int currentCapacity){ int increment = (currentCapacity&lt;MIN_CAPACITY_INCREMENT/2)?MIN_CAPACITY_INCREMENT :currentCapacity&gt;&gt;1; return currentCapacity+increment; } /** * 增加 */ public boolean add(E object){ Object[] a = array; int s = size; if(s == a.length){ //需要扩容了 Object[] newArray = new Object[newCapacity(s)]; System.arraycopy(a, 0, newArray, 0, s); array = a = newArray; } a[s] = object; size = s + 1; return true; } public int size(){ return size; } public boolean isEmpty(){ return size==0; } /** * 查找首次出现元素的下标 */ public int indexOf(Object object){ Object[] a = array; int s = size; if(object!=null){ for(int i = 0;i&lt;s;i++){ if(object.equals(a[i])){ return i; } } }else{ for(int i = 0;i&lt;s;i++){ if(a[i] == null){ return i; } } } return -1; } public int lastIndexOf(Object object){ Object[] a = array; int s = size; if(object!=null){ for(int i = s -1;i &gt;= 0;i--){ if(object.equals(a[i])){ return i; } } }else{ for(int i = s -1;i &gt;= 0;i--){ if(a[i] == null){ return i; } } } return -1; } /** * 删除某个元素 */ public E remove(int index){ Object [] a = array; int s = size; if(index &gt;= s){ throw new IndexOutOfBoundsException(); } E e = (E) a[index]; System.arraycopy(a, index+1, a, index, --s-index); a[s] = null; size = s; return e; } /** * 删除某个元素 */ public boolean remove(Object object){ Object[] a = array; int s = size; if (object == null) { for (int i = 0; i &lt; size; i++) { if (a[i] == null) { remove(i); return true; } } } else { for (int i = 0; i &lt; size; i++) { if (a[i].equals(object)) { remove(i); return true; } } } return false; } public E set(int index,E object){ Object[] a = array; if(index&gt;size){ throw new IndexOutOfBoundsException(); } E e = (E) a[index]; a[index] = object; return e; } /** * 获取 */ public E get(int index){ Object[] a = array; if(index&gt;size){ throw new IndexOutOfBoundsException(); } E e = (E) a[index]; return e; } } 代码已经说明的很清楚了，我就不多说什么了，知道底层是数组实现就ok了 HashMap public class LouisHashMap { private int size; private static final int MINIMUN_CAPACITY = 1 &lt;&lt; 2; private static final int MAXNIMUN_CAPACITY = 1 &lt;&lt; 30; //阈值 private int threshhold; //用于强制扩容,因为比minimun还小 private static final Map.Entry[] EMPTY_TABLE = new LouisEntry[MINIMUN_CAPACITY &gt;&gt; 1]; private LouisEntry&lt;K, V&gt;[] table; //核心数组 LouisEntry&lt;K, V&gt; entryOrNullKey; //空键entry public LouisHashMap() { table = (LouisEntry&lt;K, V&gt;[]) EMPTY_TABLE; threshhold = -1; } public LouisHashMap(int capacity) { if (capacity &lt; 0) { throw new IllegalArgumentException(&quot;capacity :&quot; + capacity); } else if (capacity == 0) { table = (LouisEntry&lt;K, V&gt;[]) EMPTY_TABLE; threshhold = -1; return; } else if (capacity &lt; MINIMUN_CAPACITY &amp;&amp; capacity &gt; 0){ capacity = MINIMUN_CAPACITY; } else if (capacity &gt; MAXNIMUN_CAPACITY) { capacity = MAXNIMUN_CAPACITY; } else { capacity = roundUpToPowerOfTwo(capacity); } makeTable(capacity); } /** * 添加 * @param key * @param value * @return */ public V put(K key, V value) { if (key == null) { return putValueForNullKey(value); } int hash = sencondaryHash(key.hashCode()); LouisEntry&lt;K, V&gt;[] tab = table; //将一个很散列的值 位与一个索引大小，会取得0~索引的值 int index = hash &amp; (table.length - 1); //先检查是否存在相同的键 for (LouisEntry&lt;K, V&gt; e = tab[index]; e != null; e = e.next) { //键相同hash值一定相同， hash相同键不一定相同 if (e.hash == hash &amp;&amp; key.equals(e.getKey())) { V oldValue = e.getValue(); e.setValue(value); return oldValue; } } //没有覆盖直接插入元素 if (size++ &gt; threshhold) { //创建一个新的容量的数组 tab = doubleCapacity(); index = hash &amp; (tab.length - 1); } addNewEntry(key, value, hash, index); return null; } private void addNewEntry(K key, V value, int hash, int index) { //将新创建的entry加在链表头，一句代码解决两个事情，放头部，放容易查询也容易 table[index] = new LouisEntry&lt;&gt;(key, value, hash, table[index]); } /** * get * @return */ public V get(Object key) { if (key == null) { LouisEntry&lt;K, V&gt; e = entryOrNullKey; return e == null ? null : e.getValue(); } int hash = sencondaryHash(key.hashCode()); LouisEntry&lt;K, V&gt;[] tab = table; int index = hash &amp; (tab.length - 1); for (LouisEntry&lt;K, V&gt; entry = tab[index]; entry != null; entry = entry.next) { K ekey = entry.key; //比较时，先比较对象值是否相等，在比较属性值是否相等，增加效率 if (ekey == key || (entry.hash == hash &amp;&amp; key.equals(ekey))) { return entry.value; } } return null; } /** * 双倍扩容 * @return */ private LouisEntry&lt;K, V&gt;[] doubleCapacity() { LouisEntry&lt;K, V&gt;[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXNIMUN_CAPACITY) { return oldTable; } //2的幂次方 int newCapacity = oldCapacity &lt;&lt; 1; System.out.println(&quot;扩容：&quot; + size); LouisEntry&lt;K, V&gt;[] newTable = makeTable(newCapacity); if (size == 0) { return newTable; } //开始重新散列 for (int j = 0; j &lt; oldTable.length; j++) { LouisEntry&lt;K, V&gt; e = oldTable[j]; //拿到每个键值对 if (e == null) { continue; //因为每个索引不一定有值，hash } // 与上面 int index = hash &amp; (table.length - 1);会出现两组数据，一种还在远处，一种去到length的位置 int highBit = e.hash &amp; oldCapacity; LouisEntry&lt;K, V&gt; broken = null; //位或 运算最多是原值的两倍，重新一次散列 newTable[j | highBit] = e; for (LouisEntry&lt;K, V&gt; n = e.next; n != null; e = n, n = n.next) { //n 为当前遍历的元素， e为前一个 int nextHighBit = n.hash &amp; oldCapacity; if (nextHighBit != highBit) { if (broken == null) { int nextNewIndex = j | nextHighBit; //新的索引的位置 newTable[nextNewIndex] = n; } else { broken.next = n; } broken = e; highBit = nextHighBit; } } if (broken != null) { broken.next = null; } } return newTable; } /** * hashMap键的hash算法 * @param h * @return */ private int sencondaryHash(int h) { h ^= (h&gt;&gt;&gt;20)^(h&gt;&gt;&gt;12); return h^(h&gt;&gt;&gt;7)^(h&gt;&gt;&gt;4); } /** * 放空键的键值对 * @param value * @return */ private V putValueForNullKey(V value) { LouisEntry&lt;K, V&gt; entry = entryOrNullKey; if (entry == null) { addNewEntryForNullKey(value); size++; return null; } else{ V oldValue = entry.getValue(); entry.setValue(value); return oldValue; } } private void addNewEntryForNullKey(V value) { entryOrNullKey = new LouisEntry&lt;K, V&gt;(null, value, 0, null); } /** * 根据容量创建核心数组 * @param capacity */ private LouisEntry&lt;K, V&gt;[] makeTable(int capacity) { LouisEntry&lt;K, V&gt;[] newTable = new LouisEntry[capacity]; table = newTable; threshhold = (capacity &gt;&gt;&gt; 2) + (capacity &gt;&gt;&gt; 1); return newTable; } private int roundUpToPowerOfTwo(int i) { i--; i |= i &gt;&gt;&gt; 1; // i = i | (i &gt;&gt;&gt; 1) 让所有的位都变成 1 ， 最后在加 1，就可以被2整除 i |= i &gt;&gt;&gt; 2; i |= i &gt;&gt;&gt; 4; i |= i &gt;&gt;&gt; 8; i |= i &gt;&gt;&gt; 16; return i + 1; } public int getSize() { return size; } /** * 键值对类 * @param &lt;K&gt; * @param &lt;V&gt; */ static class LouisEntry&lt;K, V&gt; implements Map.Entry&lt;K, V&gt; { final int hash; final K key; //此处用final 只赋值一次，因为key是唯一的 V value; LouisEntry&lt;K, V&gt; next; public LouisEntry(K key, V value, int hash, LouisEntry&lt;K, V&gt; next) { this.key = key; this.value = value; this.hash = hash; this.next = next; } @Override public K getKey() { return key; } @Override public V getValue() { return value; } @Override public V setValue(V value) { V oldValue = this.value; this.value = value; return oldValue; } @Override public int hashCode() { // ^ 异或运算使结果更加散列，相同为0 return (key == null ? 0 :key.hashCode()) ^ (value == null ? 0 : value.hashCode()); } } } 第一次写博客，注释也很多了，兄弟们自己将就看吧。","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://github.com/LouisShark/tags/数据结构/"},{"name":"java","slug":"java","permalink":"https://github.com/LouisShark/tags/java/"}]},{"title":"Hello World","date":"2017-04-19T09:58:12.666Z","path":"2017/04/19/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]